// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_shared_enums.proto

#include "dota_shared_enums.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.crc_)*/{}
  , /*decltype(_impl_.cpu_cycles_per_second_)*/uint64_t{0u}
  , /*decltype(_impl_.total_physical_memory_)*/uint64_t{0u}
  , /*decltype(_impl_.logical_processors_)*/0u
  , /*decltype(_impl_.is_64_bit_os_)*/false
  , /*decltype(_impl_.prefer_not_host_)*/false
  , /*decltype(_impl_.upload_measurement_)*/uint64_t{0u}} {}
struct CDOTAClientHardwareSpecsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTAClientHardwareSpecsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTAClientHardwareSpecsDefaultTypeInternal() {}
  union {
    CDOTAClientHardwareSpecs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTAClientHardwareSpecsDefaultTypeInternal _CDOTAClientHardwareSpecs_default_instance_;
PROTOBUF_CONSTEXPR CDOTASaveGame_Player::CDOTASaveGame_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hero_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.team_)*/0} {}
struct CDOTASaveGame_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTASaveGame_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTASaveGame_PlayerDefaultTypeInternal() {}
  union {
    CDOTASaveGame_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTASaveGame_PlayerDefaultTypeInternal _CDOTASaveGame_Player_default_instance_;
PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal() {}
  union {
    CDOTASaveGame_SaveInstance_PlayerPositions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal _CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_;
PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_positions_)*/{}
  , /*decltype(_impl_.game_time_)*/0u
  , /*decltype(_impl_.team1_score_)*/0u
  , /*decltype(_impl_.team2_score_)*/0u
  , /*decltype(_impl_.save_id_)*/0u
  , /*decltype(_impl_.save_time_)*/0u} {}
struct CDOTASaveGame_SaveInstanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTASaveGame_SaveInstanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTASaveGame_SaveInstanceDefaultTypeInternal() {}
  union {
    CDOTASaveGame_SaveInstance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTASaveGame_SaveInstanceDefaultTypeInternal _CDOTASaveGame_SaveInstance_default_instance_;
PROTOBUF_CONSTEXPR CDOTASaveGame::CDOTASaveGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.save_instances_)*/{}
  , /*decltype(_impl_.match_id_)*/uint64_t{0u}
  , /*decltype(_impl_.save_time_)*/0u} {}
struct CDOTASaveGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CDOTASaveGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CDOTASaveGameDefaultTypeInternal() {}
  union {
    CDOTASaveGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CDOTASaveGameDefaultTypeInternal _CDOTASaveGame_default_instance_;
PROTOBUF_CONSTEXPR CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.assist_players_)*/{}
  , /*decltype(_impl_.target_name_)*/0u
  , /*decltype(_impl_.target_source_name_)*/0u
  , /*decltype(_impl_.attacker_name_)*/0u
  , /*decltype(_impl_.damage_source_name_)*/0u
  , /*decltype(_impl_.inflictor_name_)*/0u
  , /*decltype(_impl_.is_attacker_illusion_)*/false
  , /*decltype(_impl_.is_attacker_hero_)*/false
  , /*decltype(_impl_.is_target_illusion_)*/false
  , /*decltype(_impl_.is_target_hero_)*/false
  , /*decltype(_impl_.value_)*/0u
  , /*decltype(_impl_.health_)*/0
  , /*decltype(_impl_.timestamp_)*/0
  , /*decltype(_impl_.is_visible_radiant_)*/false
  , /*decltype(_impl_.is_visible_dire_)*/false
  , /*decltype(_impl_.is_ability_toggle_on_)*/false
  , /*decltype(_impl_.is_ability_toggle_off_)*/false
  , /*decltype(_impl_.stun_duration_)*/0
  , /*decltype(_impl_.slow_duration_)*/0
  , /*decltype(_impl_.ability_level_)*/0u
  , /*decltype(_impl_.location_x_)*/0
  , /*decltype(_impl_.location_y_)*/0
  , /*decltype(_impl_.gold_reason_)*/0u
  , /*decltype(_impl_.timestamp_raw_)*/0
  , /*decltype(_impl_.modifier_duration_)*/0
  , /*decltype(_impl_.xp_reason_)*/0u
  , /*decltype(_impl_.last_hits_)*/0u
  , /*decltype(_impl_.attacker_team_)*/0u
  , /*decltype(_impl_.target_team_)*/0u
  , /*decltype(_impl_.obs_wards_placed_)*/0u
  , /*decltype(_impl_.assist_player0_)*/0u
  , /*decltype(_impl_.assist_player1_)*/0u
  , /*decltype(_impl_.assist_player2_)*/0u
  , /*decltype(_impl_.assist_player3_)*/0u
  , /*decltype(_impl_.stack_count_)*/0u
  , /*decltype(_impl_.neutral_camp_type_)*/0u
  , /*decltype(_impl_.rune_type_)*/0u
  , /*decltype(_impl_.hidden_modifier_)*/false
  , /*decltype(_impl_.is_target_building_)*/false
  , /*decltype(_impl_.is_heal_save_)*/false
  , /*decltype(_impl_.is_ultimate_ability_)*/false
  , /*decltype(_impl_.attacker_hero_level_)*/0u
  , /*decltype(_impl_.target_hero_level_)*/0u
  , /*decltype(_impl_.xpm_)*/0u
  , /*decltype(_impl_.gpm_)*/0u
  , /*decltype(_impl_.event_location_)*/0u
  , /*decltype(_impl_.damage_type_)*/0u
  , /*decltype(_impl_.damage_category_)*/0u
  , /*decltype(_impl_.networth_)*/0u
  , /*decltype(_impl_.target_is_self_)*/false
  , /*decltype(_impl_.invisibility_modifier_)*/false
  , /*decltype(_impl_.silence_modifier_)*/false
  , /*decltype(_impl_.heal_from_lifesteal_)*/false
  , /*decltype(_impl_.building_type_)*/0u
  , /*decltype(_impl_.modifier_elapsed_duration_)*/0
  , /*decltype(_impl_.modifier_purged_)*/false
  , /*decltype(_impl_.spell_evaded_)*/false
  , /*decltype(_impl_.motion_controller_modifier_)*/false
  , /*decltype(_impl_.long_range_kill_)*/false
  , /*decltype(_impl_.modifier_purge_ability_)*/0u
  , /*decltype(_impl_.modifier_purge_npc_)*/0u
  , /*decltype(_impl_.total_unit_death_count_)*/0u
  , /*decltype(_impl_.root_modifier_)*/false
  , /*decltype(_impl_.aura_modifier_)*/false
  , /*decltype(_impl_.armor_debuff_modifier_)*/false
  , /*decltype(_impl_.no_physical_damage_modifier_)*/false
  , /*decltype(_impl_.modifier_ability_)*/0u
  , /*decltype(_impl_.kill_eater_event_)*/0u
  , /*decltype(_impl_.modifier_hidden_)*/false
  , /*decltype(_impl_.inflictor_is_stolen_ability_)*/false
  , /*decltype(_impl_.spell_generated_attack_)*/false
  , /*decltype(_impl_.at_night_time_)*/false
  , /*decltype(_impl_.unit_status_label_)*/0u
  , /*decltype(_impl_.neutral_camp_team_)*/0u
  , /*decltype(_impl_.regenerated_health_)*/0
  , /*decltype(_impl_.attacker_has_scepter_)*/false
  , /*decltype(_impl_.will_reincarnate_)*/false
  , /*decltype(_impl_.uses_charges_)*/false
  , /*decltype(_impl_.tracked_stat_id_)*/0u
  , /*decltype(_impl_.type_)*/-1} {}
struct CMsgDOTACombatLogEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgDOTACombatLogEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgDOTACombatLogEntryDefaultTypeInternal() {}
  union {
    CMsgDOTACombatLogEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgDOTACombatLogEntryDefaultTypeInternal _CMsgDOTACombatLogEntry_default_instance_;
PROTOBUF_CONSTEXPR CMsgPendingEventAward::CMsgPendingEventAward(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_id_)*/0
  , /*decltype(_impl_.action_id_)*/0u
  , /*decltype(_impl_.num_to_grant_)*/0u
  , /*decltype(_impl_.score_mode_)*/0
  , /*decltype(_impl_.audit_data_)*/uint64_t{0u}
  , /*decltype(_impl_.audit_action_)*/0u} {}
struct CMsgPendingEventAwardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgPendingEventAwardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgPendingEventAwardDefaultTypeInternal() {}
  union {
    CMsgPendingEventAward _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgPendingEventAwardDefaultTypeInternal _CMsgPendingEventAward_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/0u
  , /*decltype(_impl_.value_)*/0} {}
struct CMsgMonsterHunterMaterialQuantity_MaterialCountsEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterMaterialQuantity_MaterialCountsEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterMaterialQuantity_MaterialCountsEntryDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterMaterialQuantity_MaterialCountsEntryDefaultTypeInternal _CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterMaterialQuantity::CMsgMonsterHunterMaterialQuantity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.material_counts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgMonsterHunterMaterialQuantityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterMaterialQuantityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterMaterialQuantityDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterMaterialQuantity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterMaterialQuantityDefaultTypeInternal _CMsgMonsterHunterMaterialQuantity_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigation::CMsgMonsterHunterInvestigation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.match_rewards_)*/nullptr
  , /*decltype(_impl_.hunt_rewards_)*/nullptr
  , /*decltype(_impl_.hero_id_)*/0
  , /*decltype(_impl_.persona_id_)*/0
  , /*decltype(_impl_.success_state_)*/false} {}
struct CMsgMonsterHunterInvestigationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterInvestigationDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterInvestigation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterInvestigationDefaultTypeInternal _CMsgMonsterHunterInvestigation_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigationGameState_HuntedBy::CMsgMonsterHunterInvestigationGameState_HuntedBy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hunt_rewards_)*/nullptr
  , /*decltype(_impl_.hero_id_)*/0
  , /*decltype(_impl_.persona_id_)*/0
  , /*decltype(_impl_.success_state_)*/false} {}
struct CMsgMonsterHunterInvestigationGameState_HuntedByDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigationGameState_HuntedByDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterInvestigationGameState_HuntedByDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterInvestigationGameState_HuntedBy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterInvestigationGameState_HuntedByDefaultTypeInternal _CMsgMonsterHunterInvestigationGameState_HuntedBy_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigationGameState::CMsgMonsterHunterInvestigationGameState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hunted_by_)*/{}
  , /*decltype(_impl_.selected_investigation_)*/nullptr} {}
struct CMsgMonsterHunterInvestigationGameStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterInvestigationGameStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterInvestigationGameStateDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterInvestigationGameState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterInvestigationGameStateDefaultTypeInternal _CMsgMonsterHunterInvestigationGameState_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterCodexUpdateData_KillInfo::CMsgMonsterHunterCodexUpdateData_KillInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_id_)*/0
  , /*decltype(_impl_.kill_count_)*/0} {}
struct CMsgMonsterHunterCodexUpdateData_KillInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterCodexUpdateData_KillInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterCodexUpdateData_KillInfoDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterCodexUpdateData_KillInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterCodexUpdateData_KillInfoDefaultTypeInternal _CMsgMonsterHunterCodexUpdateData_KillInfo_default_instance_;
PROTOBUF_CONSTEXPR CMsgMonsterHunterCodexUpdateData::CMsgMonsterHunterCodexUpdateData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.allies_)*/{}
  , /*decltype(_impl_.enemies_)*/{}
  , /*decltype(_impl_.player_kills_)*/{}
  , /*decltype(_impl_.player_hero_)*/0} {}
struct CMsgMonsterHunterCodexUpdateDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMonsterHunterCodexUpdateDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMonsterHunterCodexUpdateDataDefaultTypeInternal() {}
  union {
    CMsgMonsterHunterCodexUpdateData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMonsterHunterCodexUpdateDataDefaultTypeInternal _CMsgMonsterHunterCodexUpdateData_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fshared_5fenums_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[54];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fshared_5fenums_2eproto = nullptr;

const uint32_t TableStruct_dota_5fshared_5fenums_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.logical_processors_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.cpu_cycles_per_second_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.total_physical_memory_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.is_64_bit_os_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.upload_measurement_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.prefer_not_host_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _impl_.crc_),
  2,
  0,
  1,
  3,
  5,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _impl_.team_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _impl_.hero_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.game_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.team1_score_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.team2_score_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.player_positions_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.save_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _impl_.save_time_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _impl_.match_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _impl_.save_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _impl_.save_instances_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.target_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.target_source_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.attacker_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.damage_source_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.inflictor_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_attacker_illusion_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_attacker_hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_target_illusion_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_target_hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_visible_radiant_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_visible_dire_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.health_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.stun_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.slow_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_ability_toggle_on_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_ability_toggle_off_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.ability_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.location_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.location_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.gold_reason_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.timestamp_raw_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.xp_reason_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.last_hits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.attacker_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.target_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.obs_wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.assist_player0_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.assist_player1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.assist_player2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.assist_player3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.stack_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.hidden_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_target_building_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.neutral_camp_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.rune_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.assist_players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_heal_save_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.is_ultimate_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.attacker_hero_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.target_hero_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.xpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.gpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.event_location_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.target_is_self_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.damage_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.invisibility_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.damage_category_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.networth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.building_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_elapsed_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.silence_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.heal_from_lifesteal_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_purged_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.spell_evaded_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.motion_controller_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.long_range_kill_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_purge_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_purge_npc_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.root_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.total_unit_death_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.aura_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.armor_debuff_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.no_physical_damage_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.modifier_hidden_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.inflictor_is_stolen_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.kill_eater_event_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.unit_status_label_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.spell_generated_attack_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.at_night_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.attacker_has_scepter_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.neutral_camp_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.regenerated_health_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.will_reincarnate_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.uses_charges_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _impl_.tracked_stat_id_),
  78,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  12,
  13,
  9,
  10,
  11,
  16,
  17,
  14,
  15,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  36,
  37,
  34,
  35,
  ~0u,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  48,
  45,
  49,
  46,
  47,
  52,
  53,
  50,
  51,
  54,
  55,
  56,
  57,
  58,
  59,
  61,
  60,
  62,
  63,
  64,
  65,
  67,
  68,
  66,
  71,
  69,
  70,
  74,
  72,
  73,
  75,
  76,
  77,
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.action_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.num_to_grant_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.score_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.audit_action_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _impl_.audit_data_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _impl_.value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterMaterialQuantity, _impl_.material_counts_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_.persona_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_.match_rewards_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_.hunt_rewards_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigation, _impl_.success_state_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.persona_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.hunt_rewards_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.success_state_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState, _impl_.selected_investigation_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterInvestigationGameState, _impl_.hunted_by_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData_KillInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData_KillInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData_KillInfo, _impl_.hero_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData_KillInfo, _impl_.kill_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _impl_.player_hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _impl_.allies_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _impl_.enemies_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonsterHunterCodexUpdateData, _impl_.player_kills_),
  0,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, -1, sizeof(::CDOTAClientHardwareSpecs)},
  { 20, 29, -1, sizeof(::CDOTASaveGame_Player)},
  { 32, 40, -1, sizeof(::CDOTASaveGame_SaveInstance_PlayerPositions)},
  { 42, 54, -1, sizeof(::CDOTASaveGame_SaveInstance)},
  { 60, 70, -1, sizeof(::CDOTASaveGame)},
  { 74, 160, -1, sizeof(::CMsgDOTACombatLogEntry)},
  { 240, 252, -1, sizeof(::CMsgPendingEventAward)},
  { 258, 266, -1, sizeof(::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry)},
  { 268, -1, -1, sizeof(::CMsgMonsterHunterMaterialQuantity)},
  { 275, 286, -1, sizeof(::CMsgMonsterHunterInvestigation)},
  { 291, 301, -1, sizeof(::CMsgMonsterHunterInvestigationGameState_HuntedBy)},
  { 305, 313, -1, sizeof(::CMsgMonsterHunterInvestigationGameState)},
  { 315, 323, -1, sizeof(::CMsgMonsterHunterCodexUpdateData_KillInfo)},
  { 325, 335, -1, sizeof(::CMsgMonsterHunterCodexUpdateData)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CDOTAClientHardwareSpecs_default_instance_._instance,
  &::_CDOTASaveGame_Player_default_instance_._instance,
  &::_CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_._instance,
  &::_CDOTASaveGame_SaveInstance_default_instance_._instance,
  &::_CDOTASaveGame_default_instance_._instance,
  &::_CMsgDOTACombatLogEntry_default_instance_._instance,
  &::_CMsgPendingEventAward_default_instance_._instance,
  &::_CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry_default_instance_._instance,
  &::_CMsgMonsterHunterMaterialQuantity_default_instance_._instance,
  &::_CMsgMonsterHunterInvestigation_default_instance_._instance,
  &::_CMsgMonsterHunterInvestigationGameState_HuntedBy_default_instance_._instance,
  &::_CMsgMonsterHunterInvestigationGameState_default_instance_._instance,
  &::_CMsgMonsterHunterCodexUpdateData_KillInfo_default_instance_._instance,
  &::_CMsgMonsterHunterCodexUpdateData_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fshared_5fenums_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027dota_shared_enums.proto\"\314\001\n\030CDOTAClien"
  "tHardwareSpecs\022\032\n\022logical_processors\030\001 \001"
  "(\r\022\035\n\025cpu_cycles_per_second\030\002 \001(\006\022\035\n\025tot"
  "al_physical_memory\030\003 \001(\006\022\024\n\014is_64_bit_os"
  "\030\004 \001(\010\022\032\n\022upload_measurement\030\005 \001(\004\022\027\n\017pr"
  "efer_not_host\030\006 \001(\010\022\013\n\003crc\030\007 \003(\r\"\316\003\n\rCDO"
  "TASaveGame\022\020\n\010match_id\030\005 \001(\004\022\021\n\tsave_tim"
  "e\030\002 \001(\r\022&\n\007players\030\003 \003(\0132\025.CDOTASaveGame"
  ".Player\0223\n\016save_instances\030\004 \003(\0132\033.CDOTAS"
  "aveGame.SaveInstance\032Y\n\006Player\0223\n\004team\030\001"
  " \001(\0162\r.DOTA_GC_TEAM:\026DOTA_GC_TEAM_GOOD_G"
  "UYS\022\014\n\004name\030\002 \001(\t\022\014\n\004hero\030\003 \001(\t\032\337\001\n\014Save"
  "Instance\022\021\n\tgame_time\030\002 \001(\r\022\023\n\013team1_sco"
  "re\030\003 \001(\r\022\023\n\013team2_score\030\004 \001(\r\022E\n\020player_"
  "positions\030\005 \003(\0132+.CDOTASaveGame.SaveInst"
  "ance.PlayerPositions\022\017\n\007save_id\030\006 \001(\r\022\021\n"
  "\tsave_time\030\007 \001(\r\032\'\n\017PlayerPositions\022\t\n\001x"
  "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"\222\020\n\026CMsgDOTACombatLogE"
  "ntry\022;\n\004type\030\001 \001(\0162\025.DOTA_COMBATLOG_TYPE"
  "S:\026DOTA_COMBATLOG_INVALID\022\023\n\013target_name"
  "\030\002 \001(\r\022\032\n\022target_source_name\030\003 \001(\r\022\025\n\rat"
  "tacker_name\030\004 \001(\r\022\032\n\022damage_source_name\030"
  "\005 \001(\r\022\026\n\016inflictor_name\030\006 \001(\r\022\034\n\024is_atta"
  "cker_illusion\030\007 \001(\010\022\030\n\020is_attacker_hero\030"
  "\010 \001(\010\022\032\n\022is_target_illusion\030\t \001(\010\022\026\n\016is_"
  "target_hero\030\n \001(\010\022\032\n\022is_visible_radiant\030"
  "\013 \001(\010\022\027\n\017is_visible_dire\030\014 \001(\010\022\r\n\005value\030"
  "\r \001(\r\022\016\n\006health\030\016 \001(\005\022\021\n\ttimestamp\030\017 \001(\002"
  "\022\025\n\rstun_duration\030\020 \001(\002\022\025\n\rslow_duration"
  "\030\021 \001(\002\022\034\n\024is_ability_toggle_on\030\022 \001(\010\022\035\n\025"
  "is_ability_toggle_off\030\023 \001(\010\022\025\n\rability_l"
  "evel\030\024 \001(\r\022\022\n\nlocation_x\030\025 \001(\002\022\022\n\nlocati"
  "on_y\030\026 \001(\002\022\023\n\013gold_reason\030\027 \001(\r\022\025\n\rtimes"
  "tamp_raw\030\030 \001(\002\022\031\n\021modifier_duration\030\031 \001("
  "\002\022\021\n\txp_reason\030\032 \001(\r\022\021\n\tlast_hits\030\033 \001(\r\022"
  "\025\n\rattacker_team\030\034 \001(\r\022\023\n\013target_team\030\035 "
  "\001(\r\022\030\n\020obs_wards_placed\030\036 \001(\r\022\026\n\016assist_"
  "player0\030\037 \001(\r\022\026\n\016assist_player1\030  \001(\r\022\026\n"
  "\016assist_player2\030! \001(\r\022\026\n\016assist_player3\030"
  "\" \001(\r\022\023\n\013stack_count\030# \001(\r\022\027\n\017hidden_mod"
  "ifier\030$ \001(\010\022\032\n\022is_target_building\030% \001(\010\022"
  "\031\n\021neutral_camp_type\030& \001(\r\022\021\n\trune_type\030"
  "\' \001(\r\022\026\n\016assist_players\030( \003(\005\022\024\n\014is_heal"
  "_save\030) \001(\010\022\033\n\023is_ultimate_ability\030* \001(\010"
  "\022\033\n\023attacker_hero_level\030+ \001(\r\022\031\n\021target_"
  "hero_level\030, \001(\r\022\013\n\003xpm\030- \001(\r\022\013\n\003gpm\030. \001"
  "(\r\022\026\n\016event_location\030/ \001(\r\022\026\n\016target_is_"
  "self\0300 \001(\010\022\023\n\013damage_type\0301 \001(\r\022\035\n\025invis"
  "ibility_modifier\0302 \001(\010\022\027\n\017damage_categor"
  "y\0303 \001(\r\022\020\n\010networth\0304 \001(\r\022\025\n\rbuilding_ty"
  "pe\0305 \001(\r\022!\n\031modifier_elapsed_duration\0306 "
  "\001(\002\022\030\n\020silence_modifier\0307 \001(\010\022\033\n\023heal_fr"
  "om_lifesteal\0308 \001(\010\022\027\n\017modifier_purged\0309 "
  "\001(\010\022\024\n\014spell_evaded\030: \001(\010\022\"\n\032motion_cont"
  "roller_modifier\030; \001(\010\022\027\n\017long_range_kill"
  "\030< \001(\010\022\036\n\026modifier_purge_ability\030= \001(\r\022\032"
  "\n\022modifier_purge_npc\030> \001(\r\022\025\n\rroot_modif"
  "ier\030\? \001(\010\022\036\n\026total_unit_death_count\030@ \001("
  "\r\022\025\n\raura_modifier\030A \001(\010\022\035\n\025armor_debuff"
  "_modifier\030B \001(\010\022#\n\033no_physical_damage_mo"
  "difier\030C \001(\010\022\030\n\020modifier_ability\030D \001(\r\022\027"
  "\n\017modifier_hidden\030E \001(\010\022#\n\033inflictor_is_"
  "stolen_ability\030F \001(\010\022\030\n\020kill_eater_event"
  "\030G \001(\r\022\031\n\021unit_status_label\030H \001(\r\022\036\n\026spe"
  "ll_generated_attack\030I \001(\010\022\025\n\rat_night_ti"
  "me\030J \001(\010\022\034\n\024attacker_has_scepter\030K \001(\010\022\031"
  "\n\021neutral_camp_team\030L \001(\r\022\032\n\022regenerated"
  "_health\030M \001(\002\022\030\n\020will_reincarnate\030N \001(\010\022"
  "\024\n\014uses_charges\030O \001(\010\022\027\n\017tracked_stat_id"
  "\030P \001(\r\"\335\001\n\025CMsgPendingEventAward\022(\n\010even"
  "t_id\030\001 \001(\0162\007.EEvent:\rEVENT_ID_NONE\022\021\n\tac"
  "tion_id\030\002 \001(\r\022\024\n\014num_to_grant\030\003 \001(\r\022G\n\ns"
  "core_mode\030\004 \001(\0162\026.EEventActionScoreMode:"
  "\033k_eEventActionScoreMode_Add\022\024\n\014audit_ac"
  "tion\030\005 \001(\r\022\022\n\naudit_data\030\006 \001(\004\"\247\001\n!CMsgM"
  "onsterHunterMaterialQuantity\022O\n\017material"
  "_counts\030\001 \003(\01326.CMsgMonsterHunterMateria"
  "lQuantity.MaterialCountsEntry\0321\n\023Materia"
  "lCountsEntry\022\013\n\003key\030\001 \001(\r\022\r\n\005value\030\002 \001(\005"
  "\"\321\001\n\036CMsgMonsterHunterInvestigation\022\017\n\007h"
  "ero_id\030\001 \001(\005\022\022\n\npersona_id\030\002 \001(\005\0229\n\rmatc"
  "h_rewards\030\003 \001(\0132\".CMsgMonsterHunterMater"
  "ialQuantity\0228\n\014hunt_rewards\030\004 \001(\0132\".CMsg"
  "MonsterHunterMaterialQuantity\022\025\n\rsuccess"
  "_state\030\005 \001(\010\"\263\002\n\'CMsgMonsterHunterInvest"
  "igationGameState\022\?\n\026selected_investigati"
  "on\030\001 \001(\0132\037.CMsgMonsterHunterInvestigatio"
  "n\022D\n\thunted_by\030\002 \003(\01321.CMsgMonsterHunter"
  "InvestigationGameState.HuntedBy\032\200\001\n\010Hunt"
  "edBy\022\017\n\007hero_id\030\001 \001(\005\022\022\n\npersona_id\030\002 \001("
  "\005\0228\n\014hunt_rewards\030\003 \001(\0132\".CMsgMonsterHun"
  "terMaterialQuantity\022\025\n\rsuccess_state\030\004 \001"
  "(\010\"\313\001\n CMsgMonsterHunterCodexUpdateData\022"
  "\023\n\013player_hero\030\001 \001(\005\022\016\n\006allies\030\002 \003(\005\022\017\n\007"
  "enemies\030\003 \003(\005\022@\n\014player_kills\030\004 \003(\0132*.CM"
  "sgMonsterHunterCodexUpdateData.KillInfo\032"
  "/\n\010KillInfo\022\017\n\007hero_id\030\001 \001(\005\022\022\n\nkill_cou"
  "nt\030\002 \001(\005*\273\005\n\rDOTA_GameMode\022\026\n\022DOTA_GAMEM"
  "ODE_NONE\020\000\022\024\n\020DOTA_GAMEMODE_AP\020\001\022\024\n\020DOTA"
  "_GAMEMODE_CM\020\002\022\024\n\020DOTA_GAMEMODE_RD\020\003\022\024\n\020"
  "DOTA_GAMEMODE_SD\020\004\022\024\n\020DOTA_GAMEMODE_AR\020\005"
  "\022\027\n\023DOTA_GAMEMODE_INTRO\020\006\022\024\n\020DOTA_GAMEMO"
  "DE_HW\020\007\022\034\n\030DOTA_GAMEMODE_REVERSE_CM\020\010\022\026\n"
  "\022DOTA_GAMEMODE_XMAS\020\t\022\032\n\026DOTA_GAMEMODE_T"
  "UTORIAL\020\n\022\024\n\020DOTA_GAMEMODE_MO\020\013\022\024\n\020DOTA_"
  "GAMEMODE_LP\020\014\022\027\n\023DOTA_GAMEMODE_POOL1\020\r\022\024"
  "\n\020DOTA_GAMEMODE_FH\020\016\022\030\n\024DOTA_GAMEMODE_CU"
  "STOM\020\017\022\024\n\020DOTA_GAMEMODE_CD\020\020\022\024\n\020DOTA_GAM"
  "EMODE_BD\020\021\022\037\n\033DOTA_GAMEMODE_ABILITY_DRAF"
  "T\020\022\022\027\n\023DOTA_GAMEMODE_EVENT\020\023\022\026\n\022DOTA_GAM"
  "EMODE_ARDM\020\024\022\030\n\024DOTA_GAMEMODE_1V1MID\020\025\022\033"
  "\n\027DOTA_GAMEMODE_ALL_DRAFT\020\026\022\027\n\023DOTA_GAME"
  "MODE_TURBO\020\027\022\032\n\026DOTA_GAMEMODE_MUTATION\020\030"
  "\022#\n\037DOTA_GAMEMODE_COACHES_CHALLENGE\020\031\022\037\n"
  "\033DOTA_GAMEMODE_BOT_CHALLENGE\020\032*\274\004\n\016DOTA_"
  "GameState\022\035\n\031DOTA_GAMERULES_STATE_INIT\020\000"
  "\0221\n-DOTA_GAMERULES_STATE_WAIT_FOR_PLAYER"
  "S_TO_LOAD\020\001\022\'\n#DOTA_GAMERULES_STATE_HERO"
  "_SELECTION\020\002\022&\n\"DOTA_GAMERULES_STATE_STR"
  "ATEGY_TIME\020\003\022!\n\035DOTA_GAMERULES_STATE_PRE"
  "_GAME\020\004\022)\n%DOTA_GAMERULES_STATE_GAME_IN_"
  "PROGRESS\020\005\022\"\n\036DOTA_GAMERULES_STATE_POST_"
  "GAME\020\006\022#\n\037DOTA_GAMERULES_STATE_DISCONNEC"
  "T\020\007\022&\n\"DOTA_GAMERULES_STATE_TEAM_SHOWCAS"
  "E\020\010\022*\n&DOTA_GAMERULES_STATE_CUSTOM_GAME_"
  "SETUP\020\t\022-\n)DOTA_GAMERULES_STATE_WAIT_FOR"
  "_MAP_TO_LOAD\020\n\022\'\n#DOTA_GAMERULES_STATE_S"
  "CENARIO_SETUP\020\013\022%\n!DOTA_GAMERULES_STATE_"
  "PLAYER_DRAFT\020\014\022\035\n\031DOTA_GAMERULES_STATE_L"
  "AST\020\r*\251\003\n\014DOTA_GC_TEAM\022\032\n\026DOTA_GC_TEAM_G"
  "OOD_GUYS\020\000\022\031\n\025DOTA_GC_TEAM_BAD_GUYS\020\001\022\034\n"
  "\030DOTA_GC_TEAM_BROADCASTER\020\002\022\032\n\026DOTA_GC_T"
  "EAM_SPECTATOR\020\003\022\034\n\030DOTA_GC_TEAM_PLAYER_P"
  "OOL\020\004\022\027\n\023DOTA_GC_TEAM_NOTEAM\020\005\022\031\n\025DOTA_G"
  "C_TEAM_CUSTOM_1\020\006\022\031\n\025DOTA_GC_TEAM_CUSTOM"
  "_2\020\007\022\031\n\025DOTA_GC_TEAM_CUSTOM_3\020\010\022\031\n\025DOTA_"
  "GC_TEAM_CUSTOM_4\020\t\022\031\n\025DOTA_GC_TEAM_CUSTO"
  "M_5\020\n\022\031\n\025DOTA_GC_TEAM_CUSTOM_6\020\013\022\031\n\025DOTA"
  "_GC_TEAM_CUSTOM_7\020\014\022\031\n\025DOTA_GC_TEAM_CUST"
  "OM_8\020\r\022\031\n\025DOTA_GC_TEAM_NEUTRALS\020\016*\346\014\n\006EE"
  "vent\022\021\n\rEVENT_ID_NONE\020\000\022\025\n\021EVENT_ID_DIRE"
  "TIDE\020\001\022\034\n\030EVENT_ID_SPRING_FESTIVAL\020\002\022\033\n\027"
  "EVENT_ID_FROSTIVUS_2013\020\003\022\034\n\030EVENT_ID_CO"
  "MPENDIUM_2014\020\004\022\032\n\026EVENT_ID_NEXON_PC_BAN"
  "G\020\005\022\032\n\026EVENT_ID_PWRD_DAC_2015\020\006\022\033\n\027EVENT"
  "_ID_NEW_BLOOM_2015\020\007\022\037\n\033EVENT_ID_INTERNA"
  "TIONAL_2015\020\010\022\034\n\030EVENT_ID_FALL_MAJOR_201"
  "5\020\t\022\026\n\022EVENT_ID_ORACLE_PA\020\n\022$\n EVENT_ID_"
  "NEW_BLOOM_2015_PREBEAST\020\013\022\026\n\022EVENT_ID_FR"
  "OSTIVUS\020\014\022\036\n\032EVENT_ID_WINTER_MAJOR_2016\020"
  "\r\022\037\n\033EVENT_ID_INTERNATIONAL_2016\020\016\022\034\n\030EV"
  "ENT_ID_FALL_MAJOR_2016\020\017\022\036\n\032EVENT_ID_WIN"
  "TER_MAJOR_2017\020\020\022\033\n\027EVENT_ID_NEW_BLOOM_2"
  "017\020\021\022\037\n\033EVENT_ID_INTERNATIONAL_2017\020\022\022\036"
  "\n\032EVENT_ID_PLUS_SUBSCRIPTION\020\023\022\035\n\031EVENT_"
  "ID_SINGLES_DAY_2017\020\024\022\033\n\027EVENT_ID_FROSTI"
  "VUS_2017\020\025\022\037\n\033EVENT_ID_INTERNATIONAL_201"
  "8\020\026\022\033\n\027EVENT_ID_FROSTIVUS_2018\020\027\022\033\n\027EVEN"
  "T_ID_NEW_BLOOM_2019\020\030\022\037\n\033EVENT_ID_INTERN"
  "ATIONAL_2019\020\031\022\"\n\036EVENT_ID_NEW_PLAYER_EX"
  "PERIENCE\020\032\022\033\n\027EVENT_ID_FROSTIVUS_2019\020\033\022"
  "\033\n\027EVENT_ID_NEW_BLOOM_2020\020\034\022\037\n\033EVENT_ID"
  "_INTERNATIONAL_2020\020\035\022\030\n\024EVENT_ID_TEAM_F"
  "ANDOM\020\036\022\032\n\026EVENT_ID_DIRETIDE_2020\020\037\022\030\n\024E"
  "VENT_ID_SPRING_2021\020 \022\026\n\022EVENT_ID_FALL_2"
  "021\020!\022\"\n\036EVENT_ID_TEAM_FANDOM_FALL_2021\020"
  "\"\022!\n\035EVENT_ID_TEAM_2021_2022_TOUR2\020#\022\037\n\033"
  "EVENT_ID_INTERNATIONAL_2022\020$\022!\n\035EVENT_I"
  "D_TEAM_2021_2022_TOUR3\020%\022$\n EVENT_ID_TEA"
  "M_INTERNATIONAL_2022\020&\022\035\n\031EVENT_ID_PERMA"
  "NENT_GRANTS\020\'\022&\n\"EVENT_ID_MUERTA_RELEASE"
  "_SPRING2023\020(\022\034\n\030EVENT_ID_TEAM_2023_TOUR"
  "1\020)\022\034\n\030EVENT_ID_TEAM_2023_TOUR2\020*\022\034\n\030EVE"
  "NT_ID_TEAM_2023_TOUR3\020+\022\037\n\033EVENT_ID_INTE"
  "RNATIONAL_2023\020-\022\035\n\031EVENT_ID_10TH_ANNIVE"
  "RSARY\020.\022\026\n\022EVENT_ID_CROWNFALL\020/\022\033\n\027EVENT"
  "_ID_FROSTIVUS_2023\0200\022\037\n\033EVENT_ID_INTERNA"
  "TIONAL_2024\0201\022\033\n\027EVENT_ID_FROSTIVUS_2024"
  "\0202\022\033\n\027EVENT_ID_MONSTER_HUNTER\0203\022\037\n\033EVENT"
  "_ID_INTERNATIONAL_2025\0204\022\026\n\022EVENT_ID_FAL"
  "L_2025\0205\022\030\n\024EVENT_ID_WINTER_2025\0207*\273\002\n\tE"
  "RankType\022\027\n\023k_ERankType_Invalid\020\000\022\026\n\022k_E"
  "RankType_Casual\020\001\022\026\n\022k_ERankType_Ranked\020"
  "\002\022\034\n\030k_ERankType_CasualLegacy\020\003\022\034\n\030k_ERa"
  "nkType_RankedLegacy\020\004\022\034\n\030k_ERankType_Cas"
  "ualGlicko\020\005\022\034\n\030k_ERankType_RankedGlicko\020"
  "\006\022\027\n\023k_ERankType_RankMax\020\007\022\037\n\033k_ERankTyp"
  "e_BehaviorPrivate\020d\022\036\n\032k_ERankType_Behav"
  "iorPublic\020e\022\023\n\017k_ERankType_Max\020f*\312\002\n\022DOT"
  "ALeaverStatus_t\022\024\n\020DOTA_LEAVER_NONE\020\000\022\034\n"
  "\030DOTA_LEAVER_DISCONNECTED\020\001\022%\n!DOTA_LEAV"
  "ER_DISCONNECTED_TOO_LONG\020\002\022\031\n\025DOTA_LEAVE"
  "R_ABANDONED\020\003\022\023\n\017DOTA_LEAVER_AFK\020\004\022\037\n\033DO"
  "TA_LEAVER_NEVER_CONNECTED\020\005\022(\n$DOTA_LEAV"
  "ER_NEVER_CONNECTED_TOO_LONG\020\006\022\"\n\036DOTA_LE"
  "AVER_FAILED_TO_READY_UP\020\007\022\030\n\024DOTA_LEAVER"
  "_DECLINED\020\010\022 \n\034DOTA_LEAVER_DECLINED_REQU"
  "EUE\020\t*\236\002\n\025DOTAConnectionState_t\022!\n\035DOTA_"
  "CONNECTION_STATE_UNKNOWN\020\000\022+\n\'DOTA_CONNE"
  "CTION_STATE_NOT_YET_CONNECTED\020\001\022#\n\037DOTA_"
  "CONNECTION_STATE_CONNECTED\020\002\022&\n\"DOTA_CON"
  "NECTION_STATE_DISCONNECTED\020\003\022#\n\037DOTA_CON"
  "NECTION_STATE_ABANDONED\020\004\022!\n\035DOTA_CONNEC"
  "TION_STATE_LOADING\020\005\022 \n\034DOTA_CONNECTION_"
  "STATE_FAILED\020\006*\214\001\n\rFantasy_Roles\022\032\n\026FANT"
  "ASY_ROLE_UNDEFINED\020\000\022\025\n\021FANTASY_ROLE_COR"
  "E\020\001\022\030\n\024FANTASY_ROLE_SUPPORT\020\002\022\030\n\024FANTASY"
  "_ROLE_OFFLANE\020\003\022\024\n\020FANTASY_ROLE_MID\020\004*\225\005"
  "\n\017Fantasy_Scoring\022\031\n\025FANTASY_SCORING_KIL"
  "LS\020\000\022\032\n\026FANTASY_SCORING_DEATHS\020\001\022\026\n\022FANT"
  "ASY_SCORING_CS\020\002\022\027\n\023FANTASY_SCORING_GPM\020"
  "\003\022\037\n\033FANTASY_SCORING_TOWER_KILLS\020\004\022 \n\034FA"
  "NTASY_SCORING_ROSHAN_KILLS\020\005\022+\n\'FANTASY_"
  "SCORING_TEAMFIGHT_PARTICIPATION\020\006\022!\n\035FAN"
  "TASY_SCORING_WARDS_PLANTED\020\007\022!\n\035FANTASY_"
  "SCORING_CAMPS_STACKED\020\010\022!\n\035FANTASY_SCORI"
  "NG_RUNES_GRABBED\020\t\022\037\n\033FANTASY_SCORING_FI"
  "RST_BLOOD\020\n\022\031\n\025FANTASY_SCORING_STUNS\020\013\022\037"
  "\n\033FANTASY_SCORING_SMOKES_USED\020\014\022\034\n\030FANTA"
  "SY_SCORING_MADSTONE\020\r\022\"\n\036FANTASY_SCORING"
  "_WATCHERS_TAKEN\020\016\022\"\n\036FANTASY_SCORING_LOT"
  "USES_GAINED\020\017\022#\n\037FANTASY_SCORING_TORMENT"
  "OR_KILLS\020\020\022!\n\035FANTASY_SCORING_COURIER_KI"
  "LLS\020\021\022\031\n\025FANTASY_SCORING_TYPES\020\022\022\033\n\027FANT"
  "ASY_SCORING_INVALID\020\023*\212\001\n\022Fantasy_Team_S"
  "lots\022\025\n\021FANTASY_SLOT_NONE\020\000\022\025\n\021FANTASY_S"
  "LOT_CORE\020\001\022\030\n\024FANTASY_SLOT_SUPPORT\020\002\022\024\n\020"
  "FANTASY_SLOT_ANY\020\003\022\026\n\022FANTASY_SLOT_BENCH"
  "\020\004*\335\002\n\026Fantasy_Selection_Mode\022\035\n\031FANTASY"
  "_SELECTION_INVALID\020\000\022\034\n\030FANTASY_SELECTIO"
  "N_LOCKED\020\001\022\035\n\031FANTASY_SELECTION_SHUFFLE\020"
  "\002\022\037\n\033FANTASY_SELECTION_FREE_PICK\020\003\022\033\n\027FA"
  "NTASY_SELECTION_ENDED\020\004\022 \n\034FANTASY_SELEC"
  "TION_PRE_SEASON\020\005\022\037\n\033FANTASY_SELECTION_P"
  "RE_DRAFT\020\006\022\036\n\032FANTASY_SELECTION_DRAFTING"
  "\020\007\022$\n FANTASY_SELECTION_REGULAR_SEASON\020\010"
  "\022 \n\034FANTASY_SELECTION_CARD_BASED\020\t*j\n\020Fa"
  "ntasy_Gem_Type\022\031\n\025FANTASY_GEM_TYPE_RUBY\020"
  "\000\022\035\n\031FANTASY_GEM_TYPE_SAPPHIRE\020\001\022\034\n\030FANT"
  "ASY_GEM_TYPE_EMERALD\020\002*\202\006\n\025DOTAChatChann"
  "elType_t\022\034\n\030DOTAChannelType_Regional\020\000\022\032"
  "\n\026DOTAChannelType_Custom\020\001\022\031\n\025DOTAChanne"
  "lType_Party\020\002\022\031\n\025DOTAChannelType_Lobby\020\003"
  "\022\030\n\024DOTAChannelType_Team\020\004\022\031\n\025DOTAChanne"
  "lType_Guild\020\005\022\033\n\027DOTAChannelType_Fantasy"
  "\020\006\022\033\n\027DOTAChannelType_Whisper\020\007\022\033\n\027DOTAC"
  "hannelType_Console\020\010\022\027\n\023DOTAChannelType_"
  "Tab\020\t\022\033\n\027DOTAChannelType_Invalid\020\n\022\033\n\027DO"
  "TAChannelType_GameAll\020\013\022\036\n\032DOTAChannelTy"
  "pe_GameAllies\020\014\022!\n\035DOTAChannelType_GameS"
  "pectator\020\r\022 \n\034DOTAChannelType_GameCoachi"
  "ng\020\016\022\030\n\024DOTAChannelType_Cafe\020\017\022\036\n\032DOTACh"
  "annelType_CustomGame\020\020\022\033\n\027DOTAChannelTyp"
  "e_Private\020\021\022\034\n\030DOTAChannelType_PostGame\020"
  "\022\022\035\n\031DOTAChannelType_BattleCup\020\023\022!\n\035DOTA"
  "ChannelType_HLTVSpectator\020\024\022\036\n\032DOTAChann"
  "elType_GameEvents\020\025\022\032\n\026DOTAChannelType_T"
  "rivia\020\026\022\035\n\031DOTAChannelType_NewPlayer\020\027\022#"
  "\n\037DOTAChannelType_PrivateCoaching\020\030*\220\001\n\026"
  "EChatSpecialPrivileges\022!\n\035k_EChatSpecial"
  "Privileges_None\020\000\022&\n\"k_EChatSpecialPrivi"
  "leges_Moderator\020\001\022+\n\'k_EChatSpecialPrivi"
  "leges_SuperModerator\020\002*\335\003\n\016DOTACommType_"
  "t\022\027\n\023DOTA_COMM_TYPE_NONE\020\000\022\027\n\023DOTA_COMM_"
  "TYPE_PING\020\001\022\034\n\030DOTA_COMM_TYPE_CHATWHEEL\020"
  "\002\022\026\n\022DOTA_COMM_TYPE_TIP\020\003\022\027\n\023DOTA_COMM_T"
  "YPE_TEXT\020\004\022\033\n\027DOTA_COMM_TYPE_SHOWCASE\020\005\022"
  "\030\n\024DOTA_COMM_TYPE_VOICE\020\006\022\037\n\033DOTA_COMM_T"
  "YPE_ALLY_ABILITY\020\007\022\030\n\024DOTA_COMM_TYPE_PAU"
  "SE\020\010\022\033\n\027DOTA_COMM_TYPE_COACHING\020\t\022\035\n\031DOT"
  "A_COMM_TYPE_NOCOOLDOWN\020\n\022\"\n\036DOTA_COMM_TY"
  "PE_RANKEDMATCHMAKE\020\013\022\030\n\024DOTA_COMM_TYPE_D"
  "ROPS\020\014\022#\n\037DOTA_COMM_TYPE_NEWPLAYER_EXPER"
  "T\020\r\022\032\n\026DOTA_COMM_TYPE_COACHED\020\016\022\035\n\031DOTA_"
  "COMM_TYPE_MAPDRAWING\020\017*\372\001\n\017DOTACommLevel"
  "_t\022\030\n\024DOTA_COMM_LEVEL_NONE\020\000\022\034\n\030DOTA_COM"
  "M_LEVEL_COOLDOWN\020\001\022\031\n\025DOTA_COMM_LEVEL_PI"
  "NGS\020\002\022\036\n\032DOTA_COMM_LEVEL_MAPDRAWING\020\003\022\030\n"
  "\024DOTA_COMM_LEVEL_CHAT\020\004\022\033\n\027DOTA_COMM_LEV"
  "EL_TIPPING\020\005\022\031\n\025DOTA_COMM_LEVEL_VOICE\020\006\022"
  "\"\n\036DOTA_COMM_LEVEL_ALLIED_ABILITY\020\007*\275\001\n\023"
  "DOTABehaviorLevel_t\022\034\n\030DOTA_BEHAVIOR_LEV"
  "EL_NONE\020\000\022&\n\"DOTA_BEHAVIOR_LEVEL_RANKED_"
  "ALLOWED\020\001\022\037\n\033DOTA_BEHAVIOR_LEVEL_PAUSING"
  "\020\002\022\035\n\031DOTA_BEHAVIOR_LEVEL_DROPS\020\003\022 \n\034DOT"
  "A_BEHAVIOR_LEVEL_COACHING\020\004*\204\002\n\024EProfile"
  "CardSlotType\022 \n\034k_EProfileCardSlotType_E"
  "mpty\020\000\022\037\n\033k_EProfileCardSlotType_Stat\020\001\022"
  "!\n\035k_EProfileCardSlotType_Trophy\020\002\022\037\n\033k_"
  "EProfileCardSlotType_Item\020\003\022\037\n\033k_EProfil"
  "eCardSlotType_Hero\020\004\022#\n\037k_EProfileCardSl"
  "otType_Emoticon\020\005\022\037\n\033k_EProfileCardSlotT"
  "ype_Team\020\006*\225\001\n\027EMatchGroupServerStatus\022 "
  "\n\034k_EMatchGroupServerStatus_OK\020\000\0221\n-k_EM"
  "atchGroupServerStatus_LimitedAvailabilit"
  "y\020\001\022%\n!k_EMatchGroupServerStatus_Offline"
  "\020\002*O\n\014DOTA_CM_PICK\022\022\n\016DOTA_CM_RANDOM\020\000\022\025"
  "\n\021DOTA_CM_GOOD_GUYS\020\001\022\024\n\020DOTA_CM_BAD_GUY"
  "S\020\002*\264\001\n\026DOTALowPriorityBanType\022!\n\035DOTA_L"
  "OW_PRIORITY_BAN_ABANDON\020\000\022!\n\035DOTA_LOW_PR"
  "IORITY_BAN_REPORTS\020\001\022+\n\'DOTA_LOW_PRIORIT"
  "Y_BAN_SECONDARY_ABANDON\020\002\022\'\n#DOTA_LOW_PR"
  "IORITY_BAN_PRE_GAME_ROLE\020\003*\247\001\n\023DOTALobby"
  "ReadyState\022\"\n\036DOTALobbyReadyState_UNDECL"
  "ARED\020\000\022 \n\034DOTALobbyReadyState_ACCEPTED\020\001"
  "\022 \n\034DOTALobbyReadyState_DECLINED\020\002\022(\n$DO"
  "TALobbyReadyState_DECLINED_REQUEUE\020\003*\272\004\n"
  "\023DOTAJoinLobbyResult\022\034\n\030DOTA_JOIN_RESULT"
  "_SUCCESS\020\000\022$\n DOTA_JOIN_RESULT_ALREADY_I"
  "N_GAME\020\001\022\"\n\036DOTA_JOIN_RESULT_INVALID_LOB"
  "BY\020\002\022\'\n#DOTA_JOIN_RESULT_INCORRECT_PASSW"
  "ORD\020\003\022\"\n\036DOTA_JOIN_RESULT_ACCESS_DENIED\020"
  "\004\022\"\n\036DOTA_JOIN_RESULT_GENERIC_ERROR\020\005\022&\n"
  "\"DOTA_JOIN_RESULT_INCORRECT_VERSION\020\006\022\"\n"
  "\036DOTA_JOIN_RESULT_IN_TEAM_PARTY\020\007\022#\n\037DOT"
  "A_JOIN_RESULT_NO_LOBBY_FOUND\020\010\022\037\n\033DOTA_J"
  "OIN_RESULT_LOBBY_FULL\020\t\0222\n.DOTA_JOIN_RES"
  "ULT_CUSTOM_GAME_INCORRECT_VERSION\020\n\022\034\n\030D"
  "OTA_JOIN_RESULT_TIMEOUT\020\013\022)\n%DOTA_JOIN_R"
  "ESULT_CUSTOM_GAME_COOLDOWN\020\014\022\031\n\025DOTA_JOI"
  "N_RESULT_BUSY\020\r\022 \n\034DOTA_JOIN_RESULT_NO_P"
  "LAYTIME\020\016*q\n\032DOTASelectionPriorityRules\022"
  "\'\n#k_DOTASelectionPriorityRules_Manual\020\000"
  "\022*\n&k_DOTASelectionPriorityRules_Automat"
  "ic\020\001*\366\001\n\033DOTASelectionPriorityChoice\022)\n%"
  "k_DOTASelectionPriorityChoice_Invalid\020\000\022"
  "+\n\'k_DOTASelectionPriorityChoice_FirstPi"
  "ck\020\001\022,\n(k_DOTASelectionPriorityChoice_Se"
  "condPick\020\002\022)\n%k_DOTASelectionPriorityCho"
  "ice_Radiant\020\003\022&\n\"k_DOTASelectionPriority"
  "Choice_Dire\020\004*b\n\rDOTAMatchVote\022\031\n\025DOTAMa"
  "tchVote_INVALID\020\000\022\032\n\026DOTAMatchVote_POSIT"
  "IVE\020\001\022\032\n\026DOTAMatchVote_NEGATIVE\020\002*x\n\023DOT"
  "ALobbyVisibility\022\036\n\032DOTALobbyVisibility_"
  "Public\020\000\022\037\n\033DOTALobbyVisibility_Friends\020"
  "\001\022 \n\034DOTALobbyVisibility_Unlisted\020\002*\213\001\n\022"
  "EDOTAPlayerMMRType\022 \n\034k_EDOTAPlayerMMRTy"
  "pe_Invalid\020\000\022&\n\"k_EDOTAPlayerMMRType_Gen"
  "eralHidden\020\001\022+\n\'k_EDOTAPlayerMMRType_Gen"
  "eralCompetitive\020\003*s\n\021EDOTAMMRBoostType\022\034"
  "\n\030k_EDOTAMMRBoostType_None\020\000\022\036\n\032k_EDOTAM"
  "MRBoostType_Leader\020\001\022 \n\034k_EDOTAMMRBoostT"
  "ype_Follower\020\002*\320\001\n\tMatchType\022\025\n\021MATCH_TY"
  "PE_CASUAL\020\000\022\030\n\024MATCH_TYPE_COOP_BOTS\020\001\022\032\n"
  "\026MATCH_TYPE_COMPETITIVE\020\004\022\036\n\032MATCH_TYPE_"
  "WEEKEND_TOURNEY\020\005\022\024\n\020MATCH_TYPE_EVENT\020\007\022"
  " \n\034MATCH_TYPE_COACHES_CHALLENGE\020\014\022\036\n\032MAT"
  "CH_TYPE_NEW_PLAYER_POOL\020\016*\234\002\n\021DOTABotDif"
  "ficulty\022\032\n\026BOT_DIFFICULTY_PASSIVE\020\000\022\027\n\023B"
  "OT_DIFFICULTY_EASY\020\001\022\031\n\025BOT_DIFFICULTY_M"
  "EDIUM\020\002\022\027\n\023BOT_DIFFICULTY_HARD\020\003\022\031\n\025BOT_"
  "DIFFICULTY_UNFAIR\020\004\022\032\n\026BOT_DIFFICULTY_IN"
  "VALID\020\005\022\031\n\025BOT_DIFFICULTY_EXTRA1\020\006\022\031\n\025BO"
  "T_DIFFICULTY_EXTRA2\020\007\022\031\n\025BOT_DIFFICULTY_"
  "EXTRA3\020\010\022\026\n\022BOT_DIFFICULTY_NPX\020\t*\327\006\n\rDOT"
  "A_BOT_MODE\022\026\n\022DOTA_BOT_MODE_NONE\020\000\022\030\n\024DO"
  "TA_BOT_MODE_LANING\020\001\022\030\n\024DOTA_BOT_MODE_AT"
  "TACK\020\002\022\026\n\022DOTA_BOT_MODE_ROAM\020\003\022\031\n\025DOTA_B"
  "OT_MODE_RETREAT\020\004\022\035\n\031DOTA_BOT_MODE_SECRE"
  "T_SHOP\020\005\022\033\n\027DOTA_BOT_MODE_SIDE_SHOP\020\006\022\026\n"
  "\022DOTA_BOT_MODE_RUNE\020\007\022 \n\034DOTA_BOT_MODE_P"
  "USH_TOWER_TOP\020\010\022 \n\034DOTA_BOT_MODE_PUSH_TO"
  "WER_MID\020\t\022 \n\034DOTA_BOT_MODE_PUSH_TOWER_BO"
  "T\020\n\022\"\n\036DOTA_BOT_MODE_DEFEND_TOWER_TOP\020\013\022"
  "\"\n\036DOTA_BOT_MODE_DEFEND_TOWER_MID\020\014\022\"\n\036D"
  "OTA_BOT_MODE_DEFEND_TOWER_BOT\020\r\022\032\n\026DOTA_"
  "BOT_MODE_ASSEMBLE\020\016\022&\n\"DOTA_BOT_MODE_ASS"
  "EMBLE_WITH_HUMANS\020\017\022\033\n\027DOTA_BOT_MODE_TEA"
  "M_ROAM\020\020\022\026\n\022DOTA_BOT_MODE_FARM\020\021\022\035\n\031DOTA"
  "_BOT_MODE_DEFEND_ALLY\020\022\022#\n\037DOTA_BOT_MODE"
  "_EVASIVE_MANEUVERS\020\023\022\030\n\024DOTA_BOT_MODE_RO"
  "SHAN\020\024\022\026\n\022DOTA_BOT_MODE_ITEM\020\025\022\026\n\022DOTA_B"
  "OT_MODE_WARD\020\026\022\033\n\027DOTA_BOT_MODE_COMPANIO"
  "N\020\027\022\037\n\033DOTA_BOT_MODE_TUTORIAL_BOSS\020\030\022\030\n\024"
  "DOTA_BOT_MODE_MINION\020\031\022\031\n\025DOTA_BOT_MODE_"
  "OUTPOST\020\032\022\'\n#DOTA_BOT_MODE_BOT_CHALLENGE"
  "_ENDGAME\020\033*\363\001\n\016MatchLanguages\022\032\n\026MATCH_L"
  "ANGUAGE_INVALID\020\000\022\032\n\026MATCH_LANGUAGE_ENGL"
  "ISH\020\001\022\032\n\026MATCH_LANGUAGE_RUSSIAN\020\002\022\032\n\026MAT"
  "CH_LANGUAGE_CHINESE\020\003\022\031\n\025MATCH_LANGUAGE_"
  "KOREAN\020\004\022\032\n\026MATCH_LANGUAGE_SPANISH\020\005\022\035\n\031"
  "MATCH_LANGUAGE_PORTUGUESE\020\006\022\033\n\027MATCH_LAN"
  "GUAGE_ENGLISH2\020\007*\330\002\n\032ETourneyQueueDeadli"
  "neState\022\'\n#k_ETourneyQueueDeadlineState_"
  "Normal\020\000\022\'\n#k_ETourneyQueueDeadlineState"
  "_Missed\020\001\022*\n&k_ETourneyQueueDeadlineStat"
  "e_ExpiredOK\020\002\022+\n\'k_ETourneyQueueDeadline"
  "State_SeekingBye\020\003\0222\n.k_ETourneyQueueDea"
  "dlineState_EligibleForRefund\020\004\022,\n\037k_ETou"
  "rneyQueueDeadlineState_NA\020\377\377\377\377\377\377\377\377\377\001\022-\n)"
  "k_ETourneyQueueDeadlineState_ExpiringSoo"
  "n\020e*\327\005\n\rEMatchOutcome\022\033\n\027k_EMatchOutcome"
  "_Unknown\020\000\022\036\n\032k_EMatchOutcome_RadVictory"
  "\020\002\022\037\n\033k_EMatchOutcome_DireVictory\020\003\022\"\n\036k"
  "_EMatchOutcome_NeutralVictory\020\004\022 \n\034k_EMa"
  "tchOutcome_NoTeamWinner\020\005\022\"\n\036k_EMatchOut"
  "come_Custom1Victory\020\006\022\"\n\036k_EMatchOutcome"
  "_Custom2Victory\020\007\022\"\n\036k_EMatchOutcome_Cus"
  "tom3Victory\020\010\022\"\n\036k_EMatchOutcome_Custom4"
  "Victory\020\t\022\"\n\036k_EMatchOutcome_Custom5Vict"
  "ory\020\n\022\"\n\036k_EMatchOutcome_Custom6Victory\020"
  "\013\022\"\n\036k_EMatchOutcome_Custom7Victory\020\014\022\"\n"
  "\036k_EMatchOutcome_Custom8Victory\020\r\0223\n/k_E"
  "MatchOutcome_NotScored_PoorNetworkCondit"
  "ions\020@\022$\n k_EMatchOutcome_NotScored_Leav"
  "er\020A\022)\n%k_EMatchOutcome_NotScored_Server"
  "Crash\020B\022*\n&k_EMatchOutcome_NotScored_Nev"
  "erStarted\020C\022&\n\"k_EMatchOutcome_NotScored"
  "_Canceled\020D\022(\n$k_EMatchOutcome_NotScored"
  "_Suspicious\020E*\206\001\n\tELaneType\022\025\n\021LANE_TYPE"
  "_UNKNOWN\020\000\022\022\n\016LANE_TYPE_SAFE\020\001\022\021\n\rLANE_T"
  "YPE_OFF\020\002\022\021\n\rLANE_TYPE_MID\020\003\022\024\n\020LANE_TYP"
  "E_JUNGLE\020\004\022\022\n\016LANE_TYPE_ROAM\020\005*\202\007\n\nEBadg"
  "eType\022\030\n\024k_EBadgeType_Invalid\020\000\022\034\n\030k_EBa"
  "dgeType_TI7_Midweek\020\001\022\033\n\027k_EBadgeType_TI"
  "7_Finals\020\002\022\035\n\031k_EBadgeType_TI7_AllEvent\020"
  "\003\022\034\n\030k_EBadgeType_TI8_Midweek\020\004\022\033\n\027k_EBa"
  "dgeType_TI8_Finals\020\005\022\035\n\031k_EBadgeType_TI8"
  "_AllEvent\020\006\022\025\n\021k_EBadgeType_TI10\020\007\022\"\n\036k_"
  "EBadgeType_TI11_PlayoffsDay1\020\010\022\"\n\036k_EBad"
  "geType_TI11_PlayoffsDay2\020\t\022\"\n\036k_EBadgeTy"
  "pe_TI11_PlayoffsDay3\020\n\022\"\n\036k_EBadgeType_T"
  "I11_PlayoffsDay4\020\013\022#\n\037k_EBadgeType_TI11_"
  "FinalsWeekend\020\014\022\"\n\036k_EBadgeType_TI12_Pla"
  "yoffsDay1\020\r\022\"\n\036k_EBadgeType_TI12_Playoff"
  "sDay2\020\016\022\"\n\036k_EBadgeType_TI12_PlayoffsDay"
  "3\020\017\022#\n\037k_EBadgeType_TI12_FinalsWeekend\020\020"
  "\022\035\n\031k_EBadgeType_TI12_Special\020\021\022 \n\034k_EBa"
  "dgeType_TI13_FinalsDay1\020\022\022 \n\034k_EBadgeTyp"
  "e_TI13_FinalsDay2\020\023\022 \n\034k_EBadgeType_TI13"
  "_FinalsDay3\020\024\022\035\n\031k_EBadgeType_TI13_Speci"
  "al\020\025\022 \n\034k_EBadgeType_TI14_FinalsDay1\020\026\022 "
  "\n\034k_EBadgeType_TI14_FinalsDay2\020\027\022 \n\034k_EB"
  "adgeType_TI14_FinalsDay3\020\030\022 \n\034k_EBadgeTy"
  "pe_TI14_FinalsDay4\020\031\022\035\n\031k_EBadgeType_TI1"
  "4_Special\020\032*\324\001\n\rELeagueStatus\022\027\n\023LEAGUE_"
  "STATUS_UNSET\020\000\022\035\n\031LEAGUE_STATUS_UNSUBMIT"
  "TED\020\001\022\033\n\027LEAGUE_STATUS_SUBMITTED\020\002\022\032\n\026LE"
  "AGUE_STATUS_ACCEPTED\020\003\022\032\n\026LEAGUE_STATUS_"
  "REJECTED\020\004\022\033\n\027LEAGUE_STATUS_CONCLUDED\020\005\022"
  "\031\n\025LEAGUE_STATUS_DELETED\020\006*\262\001\n\rELeagueRe"
  "gion\022\027\n\023LEAGUE_REGION_UNSET\020\000\022\024\n\020LEAGUE_"
  "REGION_NA\020\001\022\024\n\020LEAGUE_REGION_SA\020\002\022\025\n\021LEA"
  "GUE_REGION_WEU\020\003\022\025\n\021LEAGUE_REGION_EEU\020\004\022"
  "\027\n\023LEAGUE_REGION_CHINA\020\005\022\025\n\021LEAGUE_REGIO"
  "N_SEA\020\006*\254\002\n\013ELeagueTier\022\025\n\021LEAGUE_TIER_U"
  "NSET\020\000\022\027\n\023LEAGUE_TIER_AMATEUR\020\001\022\034\n\030LEAGU"
  "E_TIER_PROFESSIONAL\020\002\022\025\n\021LEAGUE_TIER_MIN"
  "OR\020\003\022\025\n\021LEAGUE_TIER_MAJOR\020\004\022\035\n\031LEAGUE_TI"
  "ER_INTERNATIONAL\020\005\022\035\n\031LEAGUE_TIER_DPC_QU"
  "ALIFIER\020\006\022$\n LEAGUE_TIER_DPC_LEAGUE_QUAL"
  "IFIER\020\007\022\032\n\026LEAGUE_TIER_DPC_LEAGUE\020\010\022!\n\035L"
  "EAGUE_TIER_DPC_LEAGUE_FINALS\020\t*|\n\023ELeagu"
  "eTierCategory\022 \n\034LEAGUE_TIER_CATEGORY_AM"
  "ATEUR\020\001\022%\n!LEAGUE_TIER_CATEGORY_PROFESSI"
  "ONAL\020\002\022\034\n\030LEAGUE_TIER_CATEGORY_DPC\020\003*[\n\017"
  "ELeagueDivision\022\031\n\025LEAGUE_DIVISION_UNSET"
  "\020\000\022\025\n\021LEAGUE_DIVISION_I\020\001\022\026\n\022LEAGUE_DIVI"
  "SION_II\020\002*\253\001\n\030ELeagueBroadcastProvider\022\034"
  "\n\030LEAGUE_BROADCAST_UNKNOWN\020\000\022\032\n\026LEAGUE_B"
  "ROADCAST_STEAM\020\001\022\033\n\027LEAGUE_BROADCAST_TWI"
  "TCH\020\002\022\034\n\030LEAGUE_BROADCAST_YOUTUBE\020\003\022\032\n\026L"
  "EAGUE_BROADCAST_OTHER\020d*\206\001\n\014ELeaguePhase"
  "\022\026\n\022LEAGUE_PHASE_UNSET\020\000\022#\n\037LEAGUE_PHASE"
  "_REGIONAL_QUALIFIER\020\001\022\034\n\030LEAGUE_PHASE_GR"
  "OUP_STAGE\020\002\022\033\n\027LEAGUE_PHASE_MAIN_EVENT\020\003"
  "*\332\016\n\022ELeagueAuditAction\022\037\n\033LEAGUE_AUDIT_"
  "ACTION_INVALID\020\000\022%\n!LEAGUE_AUDIT_ACTION_"
  "LEAGUE_CREATE\020\001\022#\n\037LEAGUE_AUDIT_ACTION_L"
  "EAGUE_EDIT\020\002\022%\n!LEAGUE_AUDIT_ACTION_LEAG"
  "UE_DELETE\020\003\022(\n$LEAGUE_AUDIT_ACTION_LEAGU"
  "E_ADMIN_ADD\020\004\022+\n\'LEAGUE_AUDIT_ACTION_LEA"
  "GUE_ADMIN_REVOKE\020\005\022,\n(LEAGUE_AUDIT_ACTIO"
  "N_LEAGUE_ADMIN_PROMOTE\020\006\022)\n%LEAGUE_AUDIT"
  "_ACTION_LEAGUE_STREAM_ADD\020\007\022,\n(LEAGUE_AU"
  "DIT_ACTION_LEAGUE_STREAM_REMOVE\020\010\022,\n(LEA"
  "GUE_AUDIT_ACTION_LEAGUE_IMAGE_UPDATED\020\t\022"
  ",\n(LEAGUE_AUDIT_ACTION_LEAGUE_MESSAGE_AD"
  "DED\020\n\022(\n$LEAGUE_AUDIT_ACTION_LEAGUE_SUBM"
  "ITTED\020\013\022-\n)LEAGUE_AUDIT_ACTION_LEAGUE_SE"
  "T_PRIZE_POOL\020\014\0222\n.LEAGUE_AUDIT_ACTION_LE"
  "AGUE_ADD_PRIZE_POOL_ITEM\020\r\0225\n1LEAGUE_AUD"
  "IT_ACTION_LEAGUE_REMOVE_PRIZE_POOL_ITEM\020"
  "\016\022*\n&LEAGUE_AUDIT_ACTION_LEAGUE_MATCH_ST"
  "ART\020\017\022(\n$LEAGUE_AUDIT_ACTION_LEAGUE_MATC"
  "H_END\020\020\022/\n+LEAGUE_AUDIT_ACTION_LEAGUE_AD"
  "D_INVITED_TEAM\020\021\0222\n.LEAGUE_AUDIT_ACTION_"
  "LEAGUE_REMOVE_INVITED_TEAM\020\022\022-\n)LEAGUE_A"
  "UDIT_ACTION_LEAGUE_STATUS_CHANGED\020\023\022*\n&L"
  "EAGUE_AUDIT_ACTION_LEAGUE_STREAM_EDIT\020\024\022"
  "(\n$LEAGUE_AUDIT_ACTION_LEAGUE_TEAM_SWAP\020"
  "\025\022(\n$LEAGUE_AUDIT_ACTION_NODEGROUP_CREAT"
  "E\020d\022)\n%LEAGUE_AUDIT_ACTION_NODEGROUP_DES"
  "TROY\020e\022*\n&LEAGUE_AUDIT_ACTION_NODEGROUP_"
  "ADD_TEAM\020f\022-\n)LEAGUE_AUDIT_ACTION_NODEGR"
  "OUP_REMOVE_TEAM\020g\022/\n+LEAGUE_AUDIT_ACTION"
  "_NODEGROUP_SET_ADVANCING\020h\022&\n\"LEAGUE_AUD"
  "IT_ACTION_NODEGROUP_EDIT\020i\022*\n&LEAGUE_AUD"
  "IT_ACTION_NODEGROUP_POPULATE\020j\022+\n\'LEAGUE"
  "_AUDIT_ACTION_NODEGROUP_COMPLETED\020k\0229\n5L"
  "EAGUE_AUDIT_ACTION_NODEGROUP_SET_SECONDA"
  "RY_ADVANCING\020l\0228\n4LEAGUE_AUDIT_ACTION_NO"
  "DEGROUP_SET_TERTIARY_ADVANCING\020m\022$\n\037LEAG"
  "UE_AUDIT_ACTION_NODE_CREATE\020\310\001\022%\n LEAGUE"
  "_AUDIT_ACTION_NODE_DESTROY\020\311\001\022(\n#LEAGUE_"
  "AUDIT_ACTION_NODE_AUTOCREATE\020\312\001\022&\n!LEAGU"
  "E_AUDIT_ACTION_NODE_SET_TEAM\020\313\001\022+\n&LEAGU"
  "E_AUDIT_ACTION_NODE_SET_SERIES_ID\020\314\001\022+\n&"
  "LEAGUE_AUDIT_ACTION_NODE_SET_ADVANCING\020\315"
  "\001\022&\n!LEAGUE_AUDIT_ACTION_NODE_SET_TIME\020\316"
  "\001\022-\n(LEAGUE_AUDIT_ACTION_NODE_MATCH_COMP"
  "LETED\020\317\001\022\'\n\"LEAGUE_AUDIT_ACTION_NODE_COM"
  "PLETED\020\320\001\022\"\n\035LEAGUE_AUDIT_ACTION_NODE_ED"
  "IT\020\321\001*\217\014\n\024DOTA_COMBATLOG_TYPES\022#\n\026DOTA_C"
  "OMBATLOG_INVALID\020\377\377\377\377\377\377\377\377\377\001\022\031\n\025DOTA_COMB"
  "ATLOG_DAMAGE\020\000\022\027\n\023DOTA_COMBATLOG_HEAL\020\001\022"
  "\037\n\033DOTA_COMBATLOG_MODIFIER_ADD\020\002\022\"\n\036DOTA"
  "_COMBATLOG_MODIFIER_REMOVE\020\003\022\030\n\024DOTA_COM"
  "BATLOG_DEATH\020\004\022\032\n\026DOTA_COMBATLOG_ABILITY"
  "\020\005\022\027\n\023DOTA_COMBATLOG_ITEM\020\006\022\033\n\027DOTA_COMB"
  "ATLOG_LOCATION\020\007\022\027\n\023DOTA_COMBATLOG_GOLD\020"
  "\010\022\035\n\031DOTA_COMBATLOG_GAME_STATE\020\t\022\025\n\021DOTA"
  "_COMBATLOG_XP\020\n\022\033\n\027DOTA_COMBATLOG_PURCHA"
  "SE\020\013\022\032\n\026DOTA_COMBATLOG_BUYBACK\020\014\022\"\n\036DOTA"
  "_COMBATLOG_ABILITY_TRIGGER\020\r\022\036\n\032DOTA_COM"
  "BATLOG_PLAYERSTATS\020\016\022\034\n\030DOTA_COMBATLOG_M"
  "ULTIKILL\020\017\022\035\n\031DOTA_COMBATLOG_KILLSTREAK\020"
  "\020\022%\n!DOTA_COMBATLOG_TEAM_BUILDING_KILL\020\021"
  "\022\036\n\032DOTA_COMBATLOG_FIRST_BLOOD\020\022\022\'\n#DOTA"
  "_COMBATLOG_MODIFIER_STACK_EVENT\020\023\022%\n!DOT"
  "A_COMBATLOG_NEUTRAL_CAMP_STACK\020\024\022\036\n\032DOTA"
  "_COMBATLOG_PICKUP_RUNE\020\025\022%\n!DOTA_COMBATL"
  "OG_REVEALED_INVISIBLE\020\026\022\035\n\031DOTA_COMBATLO"
  "G_HERO_SAVED\020\027\022 \n\034DOTA_COMBATLOG_MANA_RE"
  "STORED\020\030\022\037\n\033DOTA_COMBATLOG_HERO_LEVELUP\020"
  "\031\022#\n\037DOTA_COMBATLOG_BOTTLE_HEAL_ALLY\020\032\022 "
  "\n\034DOTA_COMBATLOG_ENDGAME_STATS\020\033\022$\n DOTA"
  "_COMBATLOG_INTERRUPT_CHANNEL\020\034\022\036\n\032DOTA_C"
  "OMBATLOG_ALLIED_GOLD\020\035\022\036\n\032DOTA_COMBATLOG"
  "_AEGIS_TAKEN\020\036\022\036\n\032DOTA_COMBATLOG_MANA_DA"
  "MAGE\020\037\022,\n(DOTA_COMBATLOG_PHYSICAL_DAMAGE"
  "_PREVENTED\020 \022 \n\034DOTA_COMBATLOG_UNIT_SUMM"
  "ONED\020!\022\037\n\033DOTA_COMBATLOG_ATTACK_EVADE\020\"\022"
  "\033\n\027DOTA_COMBATLOG_TREE_CUT\020#\022\"\n\036DOTA_COM"
  "BATLOG_SUCCESSFUL_SCAN\020$\022!\n\035DOTA_COMBATL"
  "OG_END_KILLSTREAK\020%\022$\n DOTA_COMBATLOG_BL"
  "OODSTONE_CHARGE\020&\022\"\n\036DOTA_COMBATLOG_CRIT"
  "ICAL_DAMAGE\020\'\022\037\n\033DOTA_COMBATLOG_SPELL_AB"
  "SORB\020(\022\"\n\036DOTA_COMBATLOG_UNIT_TELEPORTED"
  "\020)\022#\n\037DOTA_COMBATLOG_KILL_EATER_EVENT\020*\022"
  "&\n\"DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED\020+\022"
  "&\n\"DOTA_COMBATLOG_STAT_TRACKER_PLAYER\020,*"
  "u\n\020EDPCFavoriteType\022\025\n\021FAVORITE_TYPE_ALL"
  "\020\000\022\030\n\024FAVORITE_TYPE_PLAYER\020\001\022\026\n\022FAVORITE"
  "_TYPE_TEAM\020\002\022\030\n\024FAVORITE_TYPE_LEAGUE\020\003*\250"
  "\004\n\024EDPCPushNotification\022(\n$DPC_PUSH_NOTI"
  "FICATION_MATCH_STARTING\020\001\022*\n&DPC_PUSH_NO"
  "TIFICATION_PLAYER_LEFT_TEAM\020\n\022,\n(DPC_PUS"
  "H_NOTIFICATION_PLAYER_JOINED_TEAM\020\013\0225\n1D"
  "PC_PUSH_NOTIFICATION_PLAYER_JOINED_TEAM_"
  "AS_COACH\020\014\0223\n/DPC_PUSH_NOTIFICATION_PLAY"
  "ER_LEFT_TEAM_AS_COACH\020\r\022\'\n#DPC_PUSH_NOTI"
  "FICATION_LEAGUE_RESULT\020\024\0226\n2DPC_PUSH_NOT"
  "IFICATION_PREDICTION_MATCHES_AVAILABLE\020\036"
  "\022+\n\'DPC_PUSH_NOTIFICATION_PREDICTION_RES"
  "ULT\020\037\0220\n,DPC_PUSH_NOTIFICATION_FANTASY_P"
  "LAYER_CLEARED\020(\022/\n+DPC_PUSH_NOTIFICATION"
  "_FANTASY_DAILY_SUMMARY\020)\022/\n+DPC_PUSH_NOT"
  "IFICATION_FANTASY_FINAL_RESULTS\020**Y\n\025EEv"
  "entActionScoreMode\022\037\n\033k_eEventActionScor"
  "eMode_Add\020\000\022\037\n\033k_eEventActionScoreMode_M"
  "in\020\001*\316\002\n\033EPlayerChallengeHistoryType\022)\n%"
  "k_EPlayerChallengeHistoryType_Invalid\020\000\022"
  "+\n\'k_EPlayerChallengeHistoryType_KillEat"
  "er\020\001\022/\n+k_EPlayerChallengeHistoryType_Do"
  "taPlusRelic\020\002\022=\n9k_EPlayerChallengeHisto"
  "ryType_DotaPlusHeroPlayerChallenge\020\003\0226\n2"
  "k_EPlayerChallengeHistoryType_InGameEven"
  "tChallenge\020\004\022/\n+k_EPlayerChallengeHistor"
  "yType_GuildContract\020\005*\206\002\n\026EOverwatchRepo"
  "rtReason\022$\n k_EOverwatchReportReason_Unk"
  "nown\020\000\022%\n!k_EOverwatchReportReason_Cheat"
  "ing\020\001\022$\n k_EOverwatchReportReason_Feedin"
  "g\020\002\022%\n!k_EOverwatchReportReason_Griefing"
  "\020\003\022\'\n#k_EOverwatchReportReason_Suspiciou"
  "s\020\004\022)\n%k_EOverwatchReportReason_AbilityA"
  "buse\020\005*\265\001\n\021ECandyShopUpgrade\022\'\n\032k_ECandy"
  "ShopUpgradeInvalid\020\377\377\377\377\377\377\377\377\377\001\022%\n!k_ECand"
  "yShopUpgrade_InventorySize\020\000\022#\n\037k_ECandy"
  "ShopUpgrade_RewardShelf\020\001\022+\n\'k_ECandySho"
  "pUpgrade_ExtraExchangeRecipe\020\002*\206\001\n\026EItem"
  "SuggestPreference\022!\n\035k_EItemSuggestPrefe"
  "rence_None\020\000\022\"\n\036k_EItemSuggestPreference"
  "_Liked\020\001\022%\n!k_EItemSuggestPreference_Dis"
  "liked\020\002*\267\001\n\017ETimerAlertType\022\036\n\032k_TimerAl"
  "ertType_PowerRune\020\001\022\037\n\033k_TimerAlertType_"
  "BountyRune\020\002\022!\n\035k_TimerAlertType_WisdomS"
  "hrine\020\003\022 \n\034k_TimerAlertType_JungleCamps\020"
  "\004\022\036\n\032k_TimerAlertType_LotusPool\020\005"
  ;
static ::_pbi::once_flag descriptor_table_dota_5fshared_5fenums_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fshared_5fenums_2eproto = {
    false, false, 23953, descriptor_table_protodef_dota_5fshared_5fenums_2eproto,
    "dota_shared_enums.proto",
    &descriptor_table_dota_5fshared_5fenums_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_dota_5fshared_5fenums_2eproto::offsets,
    file_level_metadata_dota_5fshared_5fenums_2eproto, file_level_enum_descriptors_dota_5fshared_5fenums_2eproto,
    file_level_service_descriptors_dota_5fshared_5fenums_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fshared_5fenums_2eproto_getter() {
  return &descriptor_table_dota_5fshared_5fenums_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fshared_5fenums_2eproto(&descriptor_table_dota_5fshared_5fenums_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[0];
}
bool DOTA_GameMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[1];
}
bool DOTA_GameState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GC_TEAM_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[2];
}
bool DOTA_GC_TEAM_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[3];
}
bool EEvent_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 55:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERankType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[4];
}
bool ERankType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 100:
    case 101:
    case 102:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALeaverStatus_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[5];
}
bool DOTALeaverStatus_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAConnectionState_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[6];
}
bool DOTAConnectionState_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Roles_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[7];
}
bool Fantasy_Roles_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Scoring_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[8];
}
bool Fantasy_Scoring_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Team_Slots_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[9];
}
bool Fantasy_Team_Slots_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Selection_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[10];
}
bool Fantasy_Selection_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Gem_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[11];
}
bool Fantasy_Gem_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAChatChannelType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[12];
}
bool DOTAChatChannelType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EChatSpecialPrivileges_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[13];
}
bool EChatSpecialPrivileges_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTACommType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[14];
}
bool DOTACommType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTACommLevel_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[15];
}
bool DOTACommLevel_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTABehaviorLevel_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[16];
}
bool DOTABehaviorLevel_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProfileCardSlotType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[17];
}
bool EProfileCardSlotType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchGroupServerStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[18];
}
bool EMatchGroupServerStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_CM_PICK_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[19];
}
bool DOTA_CM_PICK_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALowPriorityBanType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[20];
}
bool DOTALowPriorityBanType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyReadyState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[21];
}
bool DOTALobbyReadyState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAJoinLobbyResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[22];
}
bool DOTAJoinLobbyResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityRules_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[23];
}
bool DOTASelectionPriorityRules_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityChoice_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[24];
}
bool DOTASelectionPriorityChoice_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAMatchVote_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[25];
}
bool DOTAMatchVote_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyVisibility_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[26];
}
bool DOTALobbyVisibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAPlayerMMRType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[27];
}
bool EDOTAPlayerMMRType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAMMRBoostType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[28];
}
bool EDOTAMMRBoostType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[29];
}
bool MatchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 4:
    case 5:
    case 7:
    case 12:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTABotDifficulty_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[30];
}
bool DOTABotDifficulty_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_BOT_MODE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[31];
}
bool DOTA_BOT_MODE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchLanguages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[32];
}
bool MatchLanguages_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETourneyQueueDeadlineState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[33];
}
bool ETourneyQueueDeadlineState_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 101:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchOutcome_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[34];
}
bool EMatchOutcome_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELaneType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[35];
}
bool ELaneType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBadgeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[36];
}
bool EBadgeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[37];
}
bool ELeagueStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueRegion_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[38];
}
bool ELeagueRegion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[39];
}
bool ELeagueTier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTierCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[40];
}
bool ELeagueTierCategory_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueDivision_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[41];
}
bool ELeagueDivision_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueBroadcastProvider_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[42];
}
bool ELeagueBroadcastProvider_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeaguePhase_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[43];
}
bool ELeaguePhase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueAuditAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[44];
}
bool ELeagueAuditAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_COMBATLOG_TYPES_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[45];
}
bool DOTA_COMBATLOG_TYPES_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCFavoriteType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[46];
}
bool EDPCFavoriteType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCPushNotification_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[47];
}
bool EDPCPushNotification_IsValid(int value) {
  switch (value) {
    case 1:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 30:
    case 31:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEventActionScoreMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[48];
}
bool EEventActionScoreMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPlayerChallengeHistoryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[49];
}
bool EPlayerChallengeHistoryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverwatchReportReason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[50];
}
bool EOverwatchReportReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECandyShopUpgrade_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[51];
}
bool ECandyShopUpgrade_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EItemSuggestPreference_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[52];
}
bool EItemSuggestPreference_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETimerAlertType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[53];
}
bool ETimerAlertType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CDOTAClientHardwareSpecs::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientHardwareSpecs>()._impl_._has_bits_);
  static void set_has_logical_processors(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_cycles_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_physical_memory(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_64_bit_os(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_upload_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_prefer_not_host(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientHardwareSpecs)
}
CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(const CDOTAClientHardwareSpecs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTAClientHardwareSpecs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crc_){from._impl_.crc_}
    , decltype(_impl_.cpu_cycles_per_second_){}
    , decltype(_impl_.total_physical_memory_){}
    , decltype(_impl_.logical_processors_){}
    , decltype(_impl_.is_64_bit_os_){}
    , decltype(_impl_.prefer_not_host_){}
    , decltype(_impl_.upload_measurement_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.cpu_cycles_per_second_, &from._impl_.cpu_cycles_per_second_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_measurement_) -
    reinterpret_cast<char*>(&_impl_.cpu_cycles_per_second_)) + sizeof(_impl_.upload_measurement_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientHardwareSpecs)
}

inline void CDOTAClientHardwareSpecs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.crc_){arena}
    , decltype(_impl_.cpu_cycles_per_second_){uint64_t{0u}}
    , decltype(_impl_.total_physical_memory_){uint64_t{0u}}
    , decltype(_impl_.logical_processors_){0u}
    , decltype(_impl_.is_64_bit_os_){false}
    , decltype(_impl_.prefer_not_host_){false}
    , decltype(_impl_.upload_measurement_){uint64_t{0u}}
  };
}

CDOTAClientHardwareSpecs::~CDOTAClientHardwareSpecs() {
  // @@protoc_insertion_point(destructor:CDOTAClientHardwareSpecs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTAClientHardwareSpecs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.crc_.~RepeatedField();
}

void CDOTAClientHardwareSpecs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTAClientHardwareSpecs::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientHardwareSpecs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crc_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.cpu_cycles_per_second_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upload_measurement_) -
        reinterpret_cast<char*>(&_impl_.cpu_cycles_per_second_)) + sizeof(_impl_.upload_measurement_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientHardwareSpecs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 logical_processors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_logical_processors(&has_bits);
          _impl_.logical_processors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 cpu_cycles_per_second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_cpu_cycles_per_second(&has_bits);
          _impl_.cpu_cycles_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 total_physical_memory = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_total_physical_memory(&has_bits);
          _impl_.total_physical_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_64_bit_os = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_64_bit_os(&has_bits);
          _impl_.is_64_bit_os_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 upload_measurement = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_upload_measurement(&has_bits);
          _impl_.upload_measurement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool prefer_not_host = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_prefer_not_host(&has_bits);
          _impl_.prefer_not_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 crc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_crc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_crc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTAClientHardwareSpecs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientHardwareSpecs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 logical_processors = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_logical_processors(), target);
  }

  // optional fixed64 cpu_cycles_per_second = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_cpu_cycles_per_second(), target);
  }

  // optional fixed64 total_physical_memory = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_total_physical_memory(), target);
  }

  // optional bool is_64_bit_os = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_64_bit_os(), target);
  }

  // optional uint64 upload_measurement = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_upload_measurement(), target);
  }

  // optional bool prefer_not_host = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_prefer_not_host(), target);
  }

  // repeated uint32 crc = 7;
  for (int i = 0, n = this->_internal_crc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_crc(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientHardwareSpecs)
  return target;
}

size_t CDOTAClientHardwareSpecs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientHardwareSpecs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 crc = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.crc_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_crc_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed64 cpu_cycles_per_second = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 total_physical_memory = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 logical_processors = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_logical_processors());
    }

    // optional bool is_64_bit_os = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool prefer_not_host = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint64 upload_measurement = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_upload_measurement());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTAClientHardwareSpecs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTAClientHardwareSpecs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTAClientHardwareSpecs::GetClassData() const { return &_class_data_; }


void CDOTAClientHardwareSpecs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTAClientHardwareSpecs*>(&to_msg);
  auto& from = static_cast<const CDOTAClientHardwareSpecs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientHardwareSpecs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.crc_.MergeFrom(from._impl_.crc_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cpu_cycles_per_second_ = from._impl_.cpu_cycles_per_second_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_physical_memory_ = from._impl_.total_physical_memory_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.logical_processors_ = from._impl_.logical_processors_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_64_bit_os_ = from._impl_.is_64_bit_os_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.prefer_not_host_ = from._impl_.prefer_not_host_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.upload_measurement_ = from._impl_.upload_measurement_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTAClientHardwareSpecs::CopyFrom(const CDOTAClientHardwareSpecs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientHardwareSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientHardwareSpecs::IsInitialized() const {
  return true;
}

void CDOTAClientHardwareSpecs::InternalSwap(CDOTAClientHardwareSpecs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.crc_.InternalSwap(&other->_impl_.crc_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientHardwareSpecs, _impl_.upload_measurement_)
      + sizeof(CDOTAClientHardwareSpecs::_impl_.upload_measurement_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientHardwareSpecs, _impl_.cpu_cycles_per_second_)>(
          reinterpret_cast<char*>(&_impl_.cpu_cycles_per_second_),
          reinterpret_cast<char*>(&other->_impl_.cpu_cycles_per_second_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientHardwareSpecs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[0]);
}

// ===================================================================

class CDOTASaveGame_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_Player>()._impl_._has_bits_);
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame_Player::CDOTASaveGame_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.Player)
}
CDOTASaveGame_Player::CDOTASaveGame_Player(const CDOTASaveGame_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTASaveGame_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.team_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hero_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hero()) {
    _this->_impl_.hero_.Set(from._internal_hero(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.team_ = from._impl_.team_;
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.Player)
}

inline void CDOTASaveGame_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.hero_){}
    , decltype(_impl_.team_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hero_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hero_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDOTASaveGame_Player::~CDOTASaveGame_Player() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTASaveGame_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.hero_.Destroy();
}

void CDOTASaveGame_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTASaveGame_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.hero_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.team_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GC_TEAM_IsValid(val))) {
            _internal_set_team(static_cast<::DOTA_GC_TEAM>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTASaveGame.Player.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string hero = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hero();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CDOTASaveGame.Player.hero");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTASaveGame_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_team(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTASaveGame.Player.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string hero = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero().data(), static_cast<int>(this->_internal_hero().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTASaveGame.Player.hero");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_hero(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.Player)
  return target;
}

size_t CDOTASaveGame_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string hero = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero());
    }

    // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_team());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTASaveGame_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTASaveGame_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTASaveGame_Player::GetClassData() const { return &_class_data_; }


void CDOTASaveGame_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTASaveGame_Player*>(&to_msg);
  auto& from = static_cast<const CDOTASaveGame_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_hero(from._internal_hero());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team_ = from._impl_.team_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTASaveGame_Player::CopyFrom(const CDOTASaveGame_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_Player::IsInitialized() const {
  return true;
}

void CDOTASaveGame_Player::InternalSwap(CDOTASaveGame_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hero_, lhs_arena,
      &other->_impl_.hero_, rhs_arena
  );
  swap(_impl_.team_, other->_impl_.team_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[1]);
}

// ===================================================================

class CDOTASaveGame_SaveInstance_PlayerPositions::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_SaveInstance_PlayerPositions>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.SaveInstance.PlayerPositions)
}
CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(const CDOTASaveGame_SaveInstance_PlayerPositions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTASaveGame_SaveInstance_PlayerPositions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.SaveInstance.PlayerPositions)
}

inline void CDOTASaveGame_SaveInstance_PlayerPositions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

CDOTASaveGame_SaveInstance_PlayerPositions::~CDOTASaveGame_SaveInstance_PlayerPositions() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.SaveInstance.PlayerPositions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTASaveGame_SaveInstance_PlayerPositions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_SaveInstance_PlayerPositions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTASaveGame_SaveInstance_PlayerPositions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.SaveInstance.PlayerPositions)
  return target;
}

size_t CDOTASaveGame_SaveInstance_PlayerPositions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTASaveGame_SaveInstance_PlayerPositions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTASaveGame_SaveInstance_PlayerPositions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTASaveGame_SaveInstance_PlayerPositions::GetClassData() const { return &_class_data_; }


void CDOTASaveGame_SaveInstance_PlayerPositions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTASaveGame_SaveInstance_PlayerPositions*>(&to_msg);
  auto& from = static_cast<const CDOTASaveGame_SaveInstance_PlayerPositions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::CopyFrom(const CDOTASaveGame_SaveInstance_PlayerPositions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_SaveInstance_PlayerPositions::IsInitialized() const {
  return true;
}

void CDOTASaveGame_SaveInstance_PlayerPositions::InternalSwap(CDOTASaveGame_SaveInstance_PlayerPositions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance_PlayerPositions, _impl_.y_)
      + sizeof(CDOTASaveGame_SaveInstance_PlayerPositions::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance_PlayerPositions, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_SaveInstance_PlayerPositions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[2]);
}

// ===================================================================

class CDOTASaveGame_SaveInstance::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_SaveInstance>()._impl_._has_bits_);
  static void set_has_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team1_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team2_score(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_save_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_save_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.SaveInstance)
}
CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(const CDOTASaveGame_SaveInstance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTASaveGame_SaveInstance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_positions_){from._impl_.player_positions_}
    , decltype(_impl_.game_time_){}
    , decltype(_impl_.team1_score_){}
    , decltype(_impl_.team2_score_){}
    , decltype(_impl_.save_id_){}
    , decltype(_impl_.save_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.game_time_, &from._impl_.game_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.save_time_) -
    reinterpret_cast<char*>(&_impl_.game_time_)) + sizeof(_impl_.save_time_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.SaveInstance)
}

inline void CDOTASaveGame_SaveInstance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_positions_){arena}
    , decltype(_impl_.game_time_){0u}
    , decltype(_impl_.team1_score_){0u}
    , decltype(_impl_.team2_score_){0u}
    , decltype(_impl_.save_id_){0u}
    , decltype(_impl_.save_time_){0u}
  };
}

CDOTASaveGame_SaveInstance::~CDOTASaveGame_SaveInstance() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.SaveInstance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTASaveGame_SaveInstance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_positions_.~RepeatedPtrField();
}

void CDOTASaveGame_SaveInstance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTASaveGame_SaveInstance::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.SaveInstance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_positions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.game_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.save_time_) -
        reinterpret_cast<char*>(&_impl_.game_time_)) + sizeof(_impl_.save_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_SaveInstance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 game_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_game_time(&has_bits);
          _impl_.game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team1_score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_team1_score(&has_bits);
          _impl_.team1_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 team2_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_team2_score(&has_bits);
          _impl_.team2_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 save_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_save_id(&has_bits);
          _impl_.save_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 save_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_save_time(&has_bits);
          _impl_.save_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTASaveGame_SaveInstance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.SaveInstance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 game_time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_game_time(), target);
  }

  // optional uint32 team1_score = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team1_score(), target);
  }

  // optional uint32 team2_score = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team2_score(), target);
  }

  // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_positions_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_positions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 save_id = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_save_id(), target);
  }

  // optional uint32 save_time = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_save_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.SaveInstance)
  return target;
}

size_t CDOTASaveGame_SaveInstance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.SaveInstance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
  total_size += 1UL * this->_internal_player_positions_size();
  for (const auto& msg : this->_impl_.player_positions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 game_time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_game_time());
    }

    // optional uint32 team1_score = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team1_score());
    }

    // optional uint32 team2_score = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_team2_score());
    }

    // optional uint32 save_id = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_save_id());
    }

    // optional uint32 save_time = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_save_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTASaveGame_SaveInstance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTASaveGame_SaveInstance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTASaveGame_SaveInstance::GetClassData() const { return &_class_data_; }


void CDOTASaveGame_SaveInstance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTASaveGame_SaveInstance*>(&to_msg);
  auto& from = static_cast<const CDOTASaveGame_SaveInstance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.SaveInstance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.player_positions_.MergeFrom(from._impl_.player_positions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.game_time_ = from._impl_.game_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.team1_score_ = from._impl_.team1_score_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.team2_score_ = from._impl_.team2_score_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.save_id_ = from._impl_.save_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.save_time_ = from._impl_.save_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTASaveGame_SaveInstance::CopyFrom(const CDOTASaveGame_SaveInstance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.SaveInstance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_SaveInstance::IsInitialized() const {
  return true;
}

void CDOTASaveGame_SaveInstance::InternalSwap(CDOTASaveGame_SaveInstance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.player_positions_.InternalSwap(&other->_impl_.player_positions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance, _impl_.save_time_)
      + sizeof(CDOTASaveGame_SaveInstance::_impl_.save_time_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance, _impl_.game_time_)>(
          reinterpret_cast<char*>(&_impl_.game_time_),
          reinterpret_cast<char*>(&other->_impl_.game_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_SaveInstance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[3]);
}

// ===================================================================

class CDOTASaveGame::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame>()._impl_._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_save_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame::CDOTASaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame)
}
CDOTASaveGame::CDOTASaveGame(const CDOTASaveGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CDOTASaveGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.save_instances_){from._impl_.save_instances_}
    , decltype(_impl_.match_id_){}
    , decltype(_impl_.save_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.match_id_, &from._impl_.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.save_time_) -
    reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.save_time_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame)
}

inline void CDOTASaveGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.save_instances_){arena}
    , decltype(_impl_.match_id_){uint64_t{0u}}
    , decltype(_impl_.save_time_){0u}
  };
}

CDOTASaveGame::~CDOTASaveGame() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CDOTASaveGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  _impl_.save_instances_.~RepeatedPtrField();
}

void CDOTASaveGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CDOTASaveGame::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _impl_.save_instances_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.save_time_) -
        reinterpret_cast<char*>(&_impl_.match_id_)) + sizeof(_impl_.save_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 save_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_save_time(&has_bits);
          _impl_.save_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.Player players = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_save_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 match_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_match_id(&has_bits);
          _impl_.match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDOTASaveGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 save_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_save_time(), target);
  }

  // repeated .CDOTASaveGame.Player players = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_save_instances_size()); i < n; i++) {
    const auto& repfield = this->_internal_save_instances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 match_id = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_match_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame)
  return target;
}

size_t CDOTASaveGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTASaveGame.Player players = 3;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
  total_size += 1UL * this->_internal_save_instances_size();
  for (const auto& msg : this->_impl_.save_instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 match_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_match_id());
    }

    // optional uint32 save_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_save_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDOTASaveGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CDOTASaveGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDOTASaveGame::GetClassData() const { return &_class_data_; }


void CDOTASaveGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CDOTASaveGame*>(&to_msg);
  auto& from = static_cast<const CDOTASaveGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_impl_.save_instances_.MergeFrom(from._impl_.save_instances_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.match_id_ = from._impl_.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.save_time_ = from._impl_.save_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDOTASaveGame::CopyFrom(const CDOTASaveGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame::IsInitialized() const {
  return true;
}

void CDOTASaveGame::InternalSwap(CDOTASaveGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  _impl_.save_instances_.InternalSwap(&other->_impl_.save_instances_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame, _impl_.save_time_)
      + sizeof(CDOTASaveGame::_impl_.save_time_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame, _impl_.match_id_)>(
          reinterpret_cast<char*>(&_impl_.match_id_),
          reinterpret_cast<char*>(&other->_impl_.match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[4]);
}

// ===================================================================

class CMsgDOTACombatLogEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTACombatLogEntry>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[2] |= 16384u;
  }
  static void set_has_target_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_source_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attacker_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_damage_source_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_inflictor_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_attacker_illusion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_attacker_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_target_illusion(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_target_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_visible_radiant(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_visible_dire(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_stun_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_slow_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_ability_toggle_on(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_ability_toggle_off(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ability_level(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_location_x(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_location_y(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_gold_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_timestamp_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_modifier_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_xp_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_last_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_attacker_team(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_target_team(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_obs_wards_placed(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_assist_player0(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_assist_player1(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_assist_player2(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_assist_player3(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_stack_count(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_hidden_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_is_target_building(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_neutral_camp_type(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_rune_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_is_heal_save(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_is_ultimate_ability(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_attacker_hero_level(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_target_hero_level(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_xpm(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_gpm(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_event_location(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_target_is_self(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_damage_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_invisibility_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_damage_category(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_networth(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_building_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_modifier_elapsed_duration(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_silence_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_heal_from_lifesteal(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_modifier_purged(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_spell_evaded(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_motion_controller_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_long_range_kill(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static void set_has_modifier_purge_ability(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_modifier_purge_npc(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_root_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_total_unit_death_count(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_aura_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_armor_debuff_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_no_physical_damage_modifier(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_modifier_ability(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_modifier_hidden(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_inflictor_is_stolen_ability(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static void set_has_kill_eater_event(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_unit_status_label(HasBits* has_bits) {
    (*has_bits)[2] |= 128u;
  }
  static void set_has_spell_generated_attack(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static void set_has_at_night_time(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static void set_has_attacker_has_scepter(HasBits* has_bits) {
    (*has_bits)[2] |= 1024u;
  }
  static void set_has_neutral_camp_team(HasBits* has_bits) {
    (*has_bits)[2] |= 256u;
  }
  static void set_has_regenerated_health(HasBits* has_bits) {
    (*has_bits)[2] |= 512u;
  }
  static void set_has_will_reincarnate(HasBits* has_bits) {
    (*has_bits)[2] |= 2048u;
  }
  static void set_has_uses_charges(HasBits* has_bits) {
    (*has_bits)[2] |= 4096u;
  }
  static void set_has_tracked_stat_id(HasBits* has_bits) {
    (*has_bits)[2] |= 8192u;
  }
};

CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTACombatLogEntry)
}
CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(const CMsgDOTACombatLogEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgDOTACombatLogEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assist_players_){from._impl_.assist_players_}
    , decltype(_impl_.target_name_){}
    , decltype(_impl_.target_source_name_){}
    , decltype(_impl_.attacker_name_){}
    , decltype(_impl_.damage_source_name_){}
    , decltype(_impl_.inflictor_name_){}
    , decltype(_impl_.is_attacker_illusion_){}
    , decltype(_impl_.is_attacker_hero_){}
    , decltype(_impl_.is_target_illusion_){}
    , decltype(_impl_.is_target_hero_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.health_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.is_visible_radiant_){}
    , decltype(_impl_.is_visible_dire_){}
    , decltype(_impl_.is_ability_toggle_on_){}
    , decltype(_impl_.is_ability_toggle_off_){}
    , decltype(_impl_.stun_duration_){}
    , decltype(_impl_.slow_duration_){}
    , decltype(_impl_.ability_level_){}
    , decltype(_impl_.location_x_){}
    , decltype(_impl_.location_y_){}
    , decltype(_impl_.gold_reason_){}
    , decltype(_impl_.timestamp_raw_){}
    , decltype(_impl_.modifier_duration_){}
    , decltype(_impl_.xp_reason_){}
    , decltype(_impl_.last_hits_){}
    , decltype(_impl_.attacker_team_){}
    , decltype(_impl_.target_team_){}
    , decltype(_impl_.obs_wards_placed_){}
    , decltype(_impl_.assist_player0_){}
    , decltype(_impl_.assist_player1_){}
    , decltype(_impl_.assist_player2_){}
    , decltype(_impl_.assist_player3_){}
    , decltype(_impl_.stack_count_){}
    , decltype(_impl_.neutral_camp_type_){}
    , decltype(_impl_.rune_type_){}
    , decltype(_impl_.hidden_modifier_){}
    , decltype(_impl_.is_target_building_){}
    , decltype(_impl_.is_heal_save_){}
    , decltype(_impl_.is_ultimate_ability_){}
    , decltype(_impl_.attacker_hero_level_){}
    , decltype(_impl_.target_hero_level_){}
    , decltype(_impl_.xpm_){}
    , decltype(_impl_.gpm_){}
    , decltype(_impl_.event_location_){}
    , decltype(_impl_.damage_type_){}
    , decltype(_impl_.damage_category_){}
    , decltype(_impl_.networth_){}
    , decltype(_impl_.target_is_self_){}
    , decltype(_impl_.invisibility_modifier_){}
    , decltype(_impl_.silence_modifier_){}
    , decltype(_impl_.heal_from_lifesteal_){}
    , decltype(_impl_.building_type_){}
    , decltype(_impl_.modifier_elapsed_duration_){}
    , decltype(_impl_.modifier_purged_){}
    , decltype(_impl_.spell_evaded_){}
    , decltype(_impl_.motion_controller_modifier_){}
    , decltype(_impl_.long_range_kill_){}
    , decltype(_impl_.modifier_purge_ability_){}
    , decltype(_impl_.modifier_purge_npc_){}
    , decltype(_impl_.total_unit_death_count_){}
    , decltype(_impl_.root_modifier_){}
    , decltype(_impl_.aura_modifier_){}
    , decltype(_impl_.armor_debuff_modifier_){}
    , decltype(_impl_.no_physical_damage_modifier_){}
    , decltype(_impl_.modifier_ability_){}
    , decltype(_impl_.kill_eater_event_){}
    , decltype(_impl_.modifier_hidden_){}
    , decltype(_impl_.inflictor_is_stolen_ability_){}
    , decltype(_impl_.spell_generated_attack_){}
    , decltype(_impl_.at_night_time_){}
    , decltype(_impl_.unit_status_label_){}
    , decltype(_impl_.neutral_camp_team_){}
    , decltype(_impl_.regenerated_health_){}
    , decltype(_impl_.attacker_has_scepter_){}
    , decltype(_impl_.will_reincarnate_){}
    , decltype(_impl_.uses_charges_){}
    , decltype(_impl_.tracked_stat_id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.target_name_, &from._impl_.target_name_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.target_name_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTACombatLogEntry)
}

inline void CMsgDOTACombatLogEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assist_players_){arena}
    , decltype(_impl_.target_name_){0u}
    , decltype(_impl_.target_source_name_){0u}
    , decltype(_impl_.attacker_name_){0u}
    , decltype(_impl_.damage_source_name_){0u}
    , decltype(_impl_.inflictor_name_){0u}
    , decltype(_impl_.is_attacker_illusion_){false}
    , decltype(_impl_.is_attacker_hero_){false}
    , decltype(_impl_.is_target_illusion_){false}
    , decltype(_impl_.is_target_hero_){false}
    , decltype(_impl_.value_){0u}
    , decltype(_impl_.health_){0}
    , decltype(_impl_.timestamp_){0}
    , decltype(_impl_.is_visible_radiant_){false}
    , decltype(_impl_.is_visible_dire_){false}
    , decltype(_impl_.is_ability_toggle_on_){false}
    , decltype(_impl_.is_ability_toggle_off_){false}
    , decltype(_impl_.stun_duration_){0}
    , decltype(_impl_.slow_duration_){0}
    , decltype(_impl_.ability_level_){0u}
    , decltype(_impl_.location_x_){0}
    , decltype(_impl_.location_y_){0}
    , decltype(_impl_.gold_reason_){0u}
    , decltype(_impl_.timestamp_raw_){0}
    , decltype(_impl_.modifier_duration_){0}
    , decltype(_impl_.xp_reason_){0u}
    , decltype(_impl_.last_hits_){0u}
    , decltype(_impl_.attacker_team_){0u}
    , decltype(_impl_.target_team_){0u}
    , decltype(_impl_.obs_wards_placed_){0u}
    , decltype(_impl_.assist_player0_){0u}
    , decltype(_impl_.assist_player1_){0u}
    , decltype(_impl_.assist_player2_){0u}
    , decltype(_impl_.assist_player3_){0u}
    , decltype(_impl_.stack_count_){0u}
    , decltype(_impl_.neutral_camp_type_){0u}
    , decltype(_impl_.rune_type_){0u}
    , decltype(_impl_.hidden_modifier_){false}
    , decltype(_impl_.is_target_building_){false}
    , decltype(_impl_.is_heal_save_){false}
    , decltype(_impl_.is_ultimate_ability_){false}
    , decltype(_impl_.attacker_hero_level_){0u}
    , decltype(_impl_.target_hero_level_){0u}
    , decltype(_impl_.xpm_){0u}
    , decltype(_impl_.gpm_){0u}
    , decltype(_impl_.event_location_){0u}
    , decltype(_impl_.damage_type_){0u}
    , decltype(_impl_.damage_category_){0u}
    , decltype(_impl_.networth_){0u}
    , decltype(_impl_.target_is_self_){false}
    , decltype(_impl_.invisibility_modifier_){false}
    , decltype(_impl_.silence_modifier_){false}
    , decltype(_impl_.heal_from_lifesteal_){false}
    , decltype(_impl_.building_type_){0u}
    , decltype(_impl_.modifier_elapsed_duration_){0}
    , decltype(_impl_.modifier_purged_){false}
    , decltype(_impl_.spell_evaded_){false}
    , decltype(_impl_.motion_controller_modifier_){false}
    , decltype(_impl_.long_range_kill_){false}
    , decltype(_impl_.modifier_purge_ability_){0u}
    , decltype(_impl_.modifier_purge_npc_){0u}
    , decltype(_impl_.total_unit_death_count_){0u}
    , decltype(_impl_.root_modifier_){false}
    , decltype(_impl_.aura_modifier_){false}
    , decltype(_impl_.armor_debuff_modifier_){false}
    , decltype(_impl_.no_physical_damage_modifier_){false}
    , decltype(_impl_.modifier_ability_){0u}
    , decltype(_impl_.kill_eater_event_){0u}
    , decltype(_impl_.modifier_hidden_){false}
    , decltype(_impl_.inflictor_is_stolen_ability_){false}
    , decltype(_impl_.spell_generated_attack_){false}
    , decltype(_impl_.at_night_time_){false}
    , decltype(_impl_.unit_status_label_){0u}
    , decltype(_impl_.neutral_camp_team_){0u}
    , decltype(_impl_.regenerated_health_){0}
    , decltype(_impl_.attacker_has_scepter_){false}
    , decltype(_impl_.will_reincarnate_){false}
    , decltype(_impl_.uses_charges_){false}
    , decltype(_impl_.tracked_stat_id_){0u}
    , decltype(_impl_.type_){-1}
  };
}

CMsgDOTACombatLogEntry::~CMsgDOTACombatLogEntry() {
  // @@protoc_insertion_point(destructor:CMsgDOTACombatLogEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgDOTACombatLogEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.assist_players_.~RepeatedField();
}

void CMsgDOTACombatLogEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgDOTACombatLogEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTACombatLogEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.assist_players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.target_name_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_target_illusion_) -
        reinterpret_cast<char*>(&_impl_.target_name_)) + sizeof(_impl_.is_target_illusion_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.is_target_hero_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_ability_toggle_off_) -
        reinterpret_cast<char*>(&_impl_.is_target_hero_)) + sizeof(_impl_.is_ability_toggle_off_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.stun_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.modifier_duration_) -
        reinterpret_cast<char*>(&_impl_.stun_duration_)) + sizeof(_impl_.modifier_duration_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.xp_reason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.assist_player2_) -
        reinterpret_cast<char*>(&_impl_.xp_reason_)) + sizeof(_impl_.assist_player2_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.assist_player3_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_ultimate_ability_) -
        reinterpret_cast<char*>(&_impl_.assist_player3_)) + sizeof(_impl_.is_ultimate_ability_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.attacker_hero_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.networth_) -
        reinterpret_cast<char*>(&_impl_.attacker_hero_level_)) + sizeof(_impl_.networth_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.target_is_self_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.spell_evaded_) -
        reinterpret_cast<char*>(&_impl_.target_is_self_)) + sizeof(_impl_.spell_evaded_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.motion_controller_modifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.armor_debuff_modifier_) -
        reinterpret_cast<char*>(&_impl_.motion_controller_modifier_)) + sizeof(_impl_.armor_debuff_modifier_));
  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.no_physical_damage_modifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.unit_status_label_) -
        reinterpret_cast<char*>(&_impl_.no_physical_damage_modifier_)) + sizeof(_impl_.unit_status_label_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.neutral_camp_team_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tracked_stat_id_) -
        reinterpret_cast<char*>(&_impl_.neutral_camp_team_)) + sizeof(_impl_.tracked_stat_id_));
    _impl_.type_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTACombatLogEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_COMBATLOG_TYPES_IsValid(val))) {
            _internal_set_type(static_cast<::DOTA_COMBATLOG_TYPES>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_target_name(&_impl_._has_bits_);
          _impl_.target_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_source_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_target_source_name(&_impl_._has_bits_);
          _impl_.target_source_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attacker_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_attacker_name(&_impl_._has_bits_);
          _impl_.attacker_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_source_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_damage_source_name(&_impl_._has_bits_);
          _impl_.damage_source_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 inflictor_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_inflictor_name(&_impl_._has_bits_);
          _impl_.inflictor_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_attacker_illusion = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_attacker_illusion(&_impl_._has_bits_);
          _impl_.is_attacker_illusion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_attacker_hero = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_attacker_hero(&_impl_._has_bits_);
          _impl_.is_attacker_hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_target_illusion = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_target_illusion(&_impl_._has_bits_);
          _impl_.is_target_illusion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_target_hero = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_target_hero(&_impl_._has_bits_);
          _impl_.is_target_hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_visible_radiant = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_visible_radiant(&_impl_._has_bits_);
          _impl_.is_visible_radiant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_visible_dire = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_visible_dire(&_impl_._has_bits_);
          _impl_.is_visible_dire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 value = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_value(&_impl_._has_bits_);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 health = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_health(&_impl_._has_bits_);
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float timestamp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_timestamp(&_impl_._has_bits_);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float stun_duration = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_stun_duration(&_impl_._has_bits_);
          _impl_.stun_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float slow_duration = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_slow_duration(&_impl_._has_bits_);
          _impl_.slow_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ability_toggle_on = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_ability_toggle_on(&_impl_._has_bits_);
          _impl_.is_ability_toggle_on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ability_toggle_off = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_is_ability_toggle_off(&_impl_._has_bits_);
          _impl_.is_ability_toggle_off_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ability_level = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_ability_level(&_impl_._has_bits_);
          _impl_.ability_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float location_x = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_location_x(&_impl_._has_bits_);
          _impl_.location_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float location_y = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_location_y(&_impl_._has_bits_);
          _impl_.location_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gold_reason = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_gold_reason(&_impl_._has_bits_);
          _impl_.gold_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float timestamp_raw = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _Internal::set_has_timestamp_raw(&_impl_._has_bits_);
          _impl_.timestamp_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float modifier_duration = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_modifier_duration(&_impl_._has_bits_);
          _impl_.modifier_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xp_reason = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_xp_reason(&_impl_._has_bits_);
          _impl_.xp_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_hits = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_last_hits(&_impl_._has_bits_);
          _impl_.last_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attacker_team = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_attacker_team(&_impl_._has_bits_);
          _impl_.attacker_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_team = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_target_team(&_impl_._has_bits_);
          _impl_.target_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 obs_wards_placed = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_obs_wards_placed(&_impl_._has_bits_);
          _impl_.obs_wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assist_player0 = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_assist_player0(&_impl_._has_bits_);
          _impl_.assist_player0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assist_player1 = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_assist_player1(&_impl_._has_bits_);
          _impl_.assist_player1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assist_player2 = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_assist_player2(&_impl_._has_bits_);
          _impl_.assist_player2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 assist_player3 = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_assist_player3(&_impl_._has_bits_);
          _impl_.assist_player3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stack_count = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stack_count(&_impl_._has_bits_);
          _impl_.stack_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden_modifier = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hidden_modifier(&_impl_._has_bits_);
          _impl_.hidden_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_target_building = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_target_building(&_impl_._has_bits_);
          _impl_.is_target_building_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 neutral_camp_type = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_neutral_camp_type(&_impl_._has_bits_);
          _impl_.neutral_camp_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rune_type = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_rune_type(&_impl_._has_bits_);
          _impl_.rune_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 assist_players = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_assist_players(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<320>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_assist_players(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_heal_save = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_heal_save(&_impl_._has_bits_);
          _impl_.is_heal_save_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ultimate_ability = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_ultimate_ability(&_impl_._has_bits_);
          _impl_.is_ultimate_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attacker_hero_level = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_attacker_hero_level(&_impl_._has_bits_);
          _impl_.attacker_hero_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 target_hero_level = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_target_hero_level(&_impl_._has_bits_);
          _impl_.target_hero_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xpm = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_xpm(&_impl_._has_bits_);
          _impl_.xpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gpm = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_gpm(&_impl_._has_bits_);
          _impl_.gpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 event_location = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_event_location(&_impl_._has_bits_);
          _impl_.event_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool target_is_self = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_target_is_self(&_impl_._has_bits_);
          _impl_.target_is_self_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_type = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_damage_type(&_impl_._has_bits_);
          _impl_.damage_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool invisibility_modifier = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_invisibility_modifier(&_impl_._has_bits_);
          _impl_.invisibility_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damage_category = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_damage_category(&_impl_._has_bits_);
          _impl_.damage_category_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 networth = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_networth(&_impl_._has_bits_);
          _impl_.networth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 building_type = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_building_type(&_impl_._has_bits_);
          _impl_.building_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float modifier_elapsed_duration = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_modifier_elapsed_duration(&_impl_._has_bits_);
          _impl_.modifier_elapsed_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool silence_modifier = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_silence_modifier(&_impl_._has_bits_);
          _impl_.silence_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool heal_from_lifesteal = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_heal_from_lifesteal(&_impl_._has_bits_);
          _impl_.heal_from_lifesteal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool modifier_purged = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_modifier_purged(&_impl_._has_bits_);
          _impl_.modifier_purged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool spell_evaded = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_spell_evaded(&_impl_._has_bits_);
          _impl_.spell_evaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool motion_controller_modifier = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_motion_controller_modifier(&_impl_._has_bits_);
          _impl_.motion_controller_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool long_range_kill = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_long_range_kill(&_impl_._has_bits_);
          _impl_.long_range_kill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 modifier_purge_ability = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_modifier_purge_ability(&_impl_._has_bits_);
          _impl_.modifier_purge_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 modifier_purge_npc = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_modifier_purge_npc(&_impl_._has_bits_);
          _impl_.modifier_purge_npc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool root_modifier = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_root_modifier(&_impl_._has_bits_);
          _impl_.root_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_unit_death_count = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_total_unit_death_count(&_impl_._has_bits_);
          _impl_.total_unit_death_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool aura_modifier = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_aura_modifier(&_impl_._has_bits_);
          _impl_.aura_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool armor_debuff_modifier = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_armor_debuff_modifier(&_impl_._has_bits_);
          _impl_.armor_debuff_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_physical_damage_modifier = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_no_physical_damage_modifier(&_impl_._has_bits_);
          _impl_.no_physical_damage_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 modifier_ability = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_modifier_ability(&_impl_._has_bits_);
          _impl_.modifier_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool modifier_hidden = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_modifier_hidden(&_impl_._has_bits_);
          _impl_.modifier_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool inflictor_is_stolen_ability = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_inflictor_is_stolen_ability(&_impl_._has_bits_);
          _impl_.inflictor_is_stolen_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 kill_eater_event = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_kill_eater_event(&_impl_._has_bits_);
          _impl_.kill_eater_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unit_status_label = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_unit_status_label(&_impl_._has_bits_);
          _impl_.unit_status_label_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool spell_generated_attack = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_spell_generated_attack(&_impl_._has_bits_);
          _impl_.spell_generated_attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool at_night_time = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_at_night_time(&_impl_._has_bits_);
          _impl_.at_night_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool attacker_has_scepter = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_attacker_has_scepter(&_impl_._has_bits_);
          _impl_.attacker_has_scepter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 neutral_camp_team = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_neutral_camp_team(&_impl_._has_bits_);
          _impl_.neutral_camp_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float regenerated_health = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_regenerated_health(&_impl_._has_bits_);
          _impl_.regenerated_health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool will_reincarnate = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_will_reincarnate(&_impl_._has_bits_);
          _impl_.will_reincarnate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool uses_charges = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_uses_charges(&_impl_._has_bits_);
          _impl_.uses_charges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tracked_stat_id = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_tracked_stat_id(&_impl_._has_bits_);
          _impl_.tracked_stat_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgDOTACombatLogEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTACombatLogEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[2];
  // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 target_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_target_name(), target);
  }

  // optional uint32 target_source_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_target_source_name(), target);
  }

  // optional uint32 attacker_name = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_attacker_name(), target);
  }

  // optional uint32 damage_source_name = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_damage_source_name(), target);
  }

  // optional uint32 inflictor_name = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_inflictor_name(), target);
  }

  // optional bool is_attacker_illusion = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_attacker_illusion(), target);
  }

  // optional bool is_attacker_hero = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_attacker_hero(), target);
  }

  // optional bool is_target_illusion = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_target_illusion(), target);
  }

  // optional bool is_target_hero = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_target_hero(), target);
  }

  // optional bool is_visible_radiant = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_visible_radiant(), target);
  }

  // optional bool is_visible_dire = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_visible_dire(), target);
  }

  // optional uint32 value = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_value(), target);
  }

  // optional int32 health = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_health(), target);
  }

  // optional float timestamp = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_timestamp(), target);
  }

  // optional float stun_duration = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_stun_duration(), target);
  }

  // optional float slow_duration = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_slow_duration(), target);
  }

  // optional bool is_ability_toggle_on = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_ability_toggle_on(), target);
  }

  // optional bool is_ability_toggle_off = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_is_ability_toggle_off(), target);
  }

  // optional uint32 ability_level = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_ability_level(), target);
  }

  // optional float location_x = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_location_x(), target);
  }

  // optional float location_y = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_location_y(), target);
  }

  // optional uint32 gold_reason = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_gold_reason(), target);
  }

  // optional float timestamp_raw = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_timestamp_raw(), target);
  }

  // optional float modifier_duration = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_modifier_duration(), target);
  }

  // optional uint32 xp_reason = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_xp_reason(), target);
  }

  // optional uint32 last_hits = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_last_hits(), target);
  }

  // optional uint32 attacker_team = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_attacker_team(), target);
  }

  // optional uint32 target_team = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_target_team(), target);
  }

  // optional uint32 obs_wards_placed = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_obs_wards_placed(), target);
  }

  // optional uint32 assist_player0 = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_assist_player0(), target);
  }

  // optional uint32 assist_player1 = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_assist_player1(), target);
  }

  // optional uint32 assist_player2 = 33;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(33, this->_internal_assist_player2(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 assist_player3 = 34;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_assist_player3(), target);
  }

  // optional uint32 stack_count = 35;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_stack_count(), target);
  }

  // optional bool hidden_modifier = 36;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_hidden_modifier(), target);
  }

  // optional bool is_target_building = 37;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_is_target_building(), target);
  }

  // optional uint32 neutral_camp_type = 38;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(38, this->_internal_neutral_camp_type(), target);
  }

  // optional uint32 rune_type = 39;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_rune_type(), target);
  }

  // repeated int32 assist_players = 40;
  for (int i = 0, n = this->_internal_assist_players_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(40, this->_internal_assist_players(i), target);
  }

  // optional bool is_heal_save = 41;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(41, this->_internal_is_heal_save(), target);
  }

  // optional bool is_ultimate_ability = 42;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(42, this->_internal_is_ultimate_ability(), target);
  }

  // optional uint32 attacker_hero_level = 43;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(43, this->_internal_attacker_hero_level(), target);
  }

  // optional uint32 target_hero_level = 44;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(44, this->_internal_target_hero_level(), target);
  }

  // optional uint32 xpm = 45;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(45, this->_internal_xpm(), target);
  }

  // optional uint32 gpm = 46;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(46, this->_internal_gpm(), target);
  }

  // optional uint32 event_location = 47;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(47, this->_internal_event_location(), target);
  }

  // optional bool target_is_self = 48;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(48, this->_internal_target_is_self(), target);
  }

  // optional uint32 damage_type = 49;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(49, this->_internal_damage_type(), target);
  }

  // optional bool invisibility_modifier = 50;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(50, this->_internal_invisibility_modifier(), target);
  }

  // optional uint32 damage_category = 51;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(51, this->_internal_damage_category(), target);
  }

  // optional uint32 networth = 52;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(52, this->_internal_networth(), target);
  }

  // optional uint32 building_type = 53;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(53, this->_internal_building_type(), target);
  }

  // optional float modifier_elapsed_duration = 54;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(54, this->_internal_modifier_elapsed_duration(), target);
  }

  // optional bool silence_modifier = 55;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(55, this->_internal_silence_modifier(), target);
  }

  // optional bool heal_from_lifesteal = 56;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(56, this->_internal_heal_from_lifesteal(), target);
  }

  // optional bool modifier_purged = 57;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(57, this->_internal_modifier_purged(), target);
  }

  // optional bool spell_evaded = 58;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(58, this->_internal_spell_evaded(), target);
  }

  // optional bool motion_controller_modifier = 59;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(59, this->_internal_motion_controller_modifier(), target);
  }

  // optional bool long_range_kill = 60;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(60, this->_internal_long_range_kill(), target);
  }

  // optional uint32 modifier_purge_ability = 61;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(61, this->_internal_modifier_purge_ability(), target);
  }

  // optional uint32 modifier_purge_npc = 62;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(62, this->_internal_modifier_purge_npc(), target);
  }

  // optional bool root_modifier = 63;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(63, this->_internal_root_modifier(), target);
  }

  // optional uint32 total_unit_death_count = 64;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(64, this->_internal_total_unit_death_count(), target);
  }

  // optional bool aura_modifier = 65;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(65, this->_internal_aura_modifier(), target);
  }

  // optional bool armor_debuff_modifier = 66;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(66, this->_internal_armor_debuff_modifier(), target);
  }

  cached_has_bits = _impl_._has_bits_[2];
  // optional bool no_physical_damage_modifier = 67;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(67, this->_internal_no_physical_damage_modifier(), target);
  }

  // optional uint32 modifier_ability = 68;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(68, this->_internal_modifier_ability(), target);
  }

  // optional bool modifier_hidden = 69;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(69, this->_internal_modifier_hidden(), target);
  }

  // optional bool inflictor_is_stolen_ability = 70;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(70, this->_internal_inflictor_is_stolen_ability(), target);
  }

  // optional uint32 kill_eater_event = 71;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(71, this->_internal_kill_eater_event(), target);
  }

  // optional uint32 unit_status_label = 72;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(72, this->_internal_unit_status_label(), target);
  }

  // optional bool spell_generated_attack = 73;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(73, this->_internal_spell_generated_attack(), target);
  }

  // optional bool at_night_time = 74;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(74, this->_internal_at_night_time(), target);
  }

  // optional bool attacker_has_scepter = 75;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(75, this->_internal_attacker_has_scepter(), target);
  }

  // optional uint32 neutral_camp_team = 76;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(76, this->_internal_neutral_camp_team(), target);
  }

  // optional float regenerated_health = 77;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(77, this->_internal_regenerated_health(), target);
  }

  // optional bool will_reincarnate = 78;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(78, this->_internal_will_reincarnate(), target);
  }

  // optional bool uses_charges = 79;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(79, this->_internal_uses_charges(), target);
  }

  // optional uint32 tracked_stat_id = 80;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(80, this->_internal_tracked_stat_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTACombatLogEntry)
  return target;
}

size_t CMsgDOTACombatLogEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTACombatLogEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 assist_players = 40;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.assist_players_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_assist_players_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 target_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_name());
    }

    // optional uint32 target_source_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_source_name());
    }

    // optional uint32 attacker_name = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attacker_name());
    }

    // optional uint32 damage_source_name = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_damage_source_name());
    }

    // optional uint32 inflictor_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_inflictor_name());
    }

    // optional bool is_attacker_illusion = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_attacker_hero = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_target_illusion = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_target_hero = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 value = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

    // optional int32 health = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_health());
    }

    // optional float timestamp = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional bool is_visible_radiant = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_visible_dire = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_ability_toggle_on = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_ability_toggle_off = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float stun_duration = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float slow_duration = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional uint32 ability_level = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ability_level());
    }

    // optional float location_x = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float location_y = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional uint32 gold_reason = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gold_reason());
    }

    // optional float timestamp_raw = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float modifier_duration = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 xp_reason = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_xp_reason());
    }

    // optional uint32 last_hits = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_hits());
    }

    // optional uint32 attacker_team = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_attacker_team());
    }

    // optional uint32 target_team = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_target_team());
    }

    // optional uint32 obs_wards_placed = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_obs_wards_placed());
    }

    // optional uint32 assist_player0 = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assist_player0());
    }

    // optional uint32 assist_player1 = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assist_player1());
    }

    // optional uint32 assist_player2 = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assist_player2());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 assist_player3 = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_assist_player3());
    }

    // optional uint32 stack_count = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_stack_count());
    }

    // optional uint32 neutral_camp_type = 38;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_neutral_camp_type());
    }

    // optional uint32 rune_type = 39;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rune_type());
    }

    // optional bool hidden_modifier = 36;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool is_target_building = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool is_heal_save = 41;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool is_ultimate_ability = 42;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 attacker_hero_level = 43;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_attacker_hero_level());
    }

    // optional uint32 target_hero_level = 44;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_target_hero_level());
    }

    // optional uint32 xpm = 45;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_xpm());
    }

    // optional uint32 gpm = 46;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_gpm());
    }

    // optional uint32 event_location = 47;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_event_location());
    }

    // optional uint32 damage_type = 49;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage_type());
    }

    // optional uint32 damage_category = 51;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_damage_category());
    }

    // optional uint32 networth = 52;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_networth());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool target_is_self = 48;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool invisibility_modifier = 50;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool silence_modifier = 55;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool heal_from_lifesteal = 56;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint32 building_type = 53;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_building_type());
    }

    // optional float modifier_elapsed_duration = 54;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional bool modifier_purged = 57;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool spell_evaded = 58;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool motion_controller_modifier = 59;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool long_range_kill = 60;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 modifier_purge_ability = 61;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_modifier_purge_ability());
    }

    // optional uint32 modifier_purge_npc = 62;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_modifier_purge_npc());
    }

    // optional uint32 total_unit_death_count = 64;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_total_unit_death_count());
    }

    // optional bool root_modifier = 63;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool aura_modifier = 65;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool armor_debuff_modifier = 66;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool no_physical_damage_modifier = 67;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional uint32 modifier_ability = 68;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_modifier_ability());
    }

    // optional uint32 kill_eater_event = 71;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_kill_eater_event());
    }

    // optional bool modifier_hidden = 69;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool inflictor_is_stolen_ability = 70;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool spell_generated_attack = 73;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool at_night_time = 74;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional uint32 unit_status_label = 72;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_unit_status_label());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 neutral_camp_team = 76;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_neutral_camp_team());
    }

    // optional float regenerated_health = 77;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 4;
    }

    // optional bool attacker_has_scepter = 75;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool will_reincarnate = 78;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool uses_charges = 79;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional uint32 tracked_stat_id = 80;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tracked_stat_id());
    }

    // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgDOTACombatLogEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgDOTACombatLogEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgDOTACombatLogEntry::GetClassData() const { return &_class_data_; }


void CMsgDOTACombatLogEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgDOTACombatLogEntry*>(&to_msg);
  auto& from = static_cast<const CMsgDOTACombatLogEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTACombatLogEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.assist_players_.MergeFrom(from._impl_.assist_players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.target_name_ = from._impl_.target_name_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.target_source_name_ = from._impl_.target_source_name_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.attacker_name_ = from._impl_.attacker_name_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.damage_source_name_ = from._impl_.damage_source_name_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.inflictor_name_ = from._impl_.inflictor_name_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_attacker_illusion_ = from._impl_.is_attacker_illusion_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_attacker_hero_ = from._impl_.is_attacker_hero_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_target_illusion_ = from._impl_.is_target_illusion_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.is_target_hero_ = from._impl_.is_target_hero_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.health_ = from._impl_.health_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.is_visible_radiant_ = from._impl_.is_visible_radiant_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.is_visible_dire_ = from._impl_.is_visible_dire_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_ability_toggle_on_ = from._impl_.is_ability_toggle_on_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_ability_toggle_off_ = from._impl_.is_ability_toggle_off_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.stun_duration_ = from._impl_.stun_duration_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.slow_duration_ = from._impl_.slow_duration_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.ability_level_ = from._impl_.ability_level_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.location_x_ = from._impl_.location_x_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.location_y_ = from._impl_.location_y_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.gold_reason_ = from._impl_.gold_reason_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.timestamp_raw_ = from._impl_.timestamp_raw_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.modifier_duration_ = from._impl_.modifier_duration_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.xp_reason_ = from._impl_.xp_reason_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.last_hits_ = from._impl_.last_hits_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.attacker_team_ = from._impl_.attacker_team_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.target_team_ = from._impl_.target_team_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.obs_wards_placed_ = from._impl_.obs_wards_placed_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.assist_player0_ = from._impl_.assist_player0_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.assist_player1_ = from._impl_.assist_player1_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.assist_player2_ = from._impl_.assist_player2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.assist_player3_ = from._impl_.assist_player3_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stack_count_ = from._impl_.stack_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.neutral_camp_type_ = from._impl_.neutral_camp_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rune_type_ = from._impl_.rune_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hidden_modifier_ = from._impl_.hidden_modifier_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_target_building_ = from._impl_.is_target_building_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_heal_save_ = from._impl_.is_heal_save_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_ultimate_ability_ = from._impl_.is_ultimate_ability_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.attacker_hero_level_ = from._impl_.attacker_hero_level_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.target_hero_level_ = from._impl_.target_hero_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.xpm_ = from._impl_.xpm_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.gpm_ = from._impl_.gpm_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.event_location_ = from._impl_.event_location_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.damage_type_ = from._impl_.damage_type_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.damage_category_ = from._impl_.damage_category_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.networth_ = from._impl_.networth_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.target_is_self_ = from._impl_.target_is_self_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.invisibility_modifier_ = from._impl_.invisibility_modifier_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.silence_modifier_ = from._impl_.silence_modifier_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.heal_from_lifesteal_ = from._impl_.heal_from_lifesteal_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.building_type_ = from._impl_.building_type_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.modifier_elapsed_duration_ = from._impl_.modifier_elapsed_duration_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.modifier_purged_ = from._impl_.modifier_purged_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.spell_evaded_ = from._impl_.spell_evaded_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.motion_controller_modifier_ = from._impl_.motion_controller_modifier_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.long_range_kill_ = from._impl_.long_range_kill_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.modifier_purge_ability_ = from._impl_.modifier_purge_ability_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.modifier_purge_npc_ = from._impl_.modifier_purge_npc_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.total_unit_death_count_ = from._impl_.total_unit_death_count_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.root_modifier_ = from._impl_.root_modifier_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.aura_modifier_ = from._impl_.aura_modifier_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.armor_debuff_modifier_ = from._impl_.armor_debuff_modifier_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.no_physical_damage_modifier_ = from._impl_.no_physical_damage_modifier_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.modifier_ability_ = from._impl_.modifier_ability_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.kill_eater_event_ = from._impl_.kill_eater_event_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.modifier_hidden_ = from._impl_.modifier_hidden_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.inflictor_is_stolen_ability_ = from._impl_.inflictor_is_stolen_ability_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.spell_generated_attack_ = from._impl_.spell_generated_attack_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.at_night_time_ = from._impl_.at_night_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.unit_status_label_ = from._impl_.unit_status_label_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.neutral_camp_team_ = from._impl_.neutral_camp_team_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.regenerated_health_ = from._impl_.regenerated_health_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.attacker_has_scepter_ = from._impl_.attacker_has_scepter_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.will_reincarnate_ = from._impl_.will_reincarnate_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.uses_charges_ = from._impl_.uses_charges_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.tracked_stat_id_ = from._impl_.tracked_stat_id_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[2] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgDOTACombatLogEntry::CopyFrom(const CMsgDOTACombatLogEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTACombatLogEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTACombatLogEntry::IsInitialized() const {
  return true;
}

void CMsgDOTACombatLogEntry::InternalSwap(CMsgDOTACombatLogEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  swap(_impl_._has_bits_[2], other->_impl_._has_bits_[2]);
  _impl_.assist_players_.InternalSwap(&other->_impl_.assist_players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTACombatLogEntry, _impl_.tracked_stat_id_)
      + sizeof(CMsgDOTACombatLogEntry::_impl_.tracked_stat_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTACombatLogEntry, _impl_.target_name_)>(
          reinterpret_cast<char*>(&_impl_.target_name_),
          reinterpret_cast<char*>(&other->_impl_.target_name_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTACombatLogEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[5]);
}

// ===================================================================

class CMsgPendingEventAward::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPendingEventAward>()._impl_._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_to_grant(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_score_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_audit_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audit_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgPendingEventAward::CMsgPendingEventAward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgPendingEventAward)
}
CMsgPendingEventAward::CMsgPendingEventAward(const CMsgPendingEventAward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgPendingEventAward* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){}
    , decltype(_impl_.action_id_){}
    , decltype(_impl_.num_to_grant_){}
    , decltype(_impl_.score_mode_){}
    , decltype(_impl_.audit_data_){}
    , decltype(_impl_.audit_action_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_id_, &from._impl_.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.audit_action_) -
    reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.audit_action_));
  // @@protoc_insertion_point(copy_constructor:CMsgPendingEventAward)
}

inline void CMsgPendingEventAward::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_id_){0}
    , decltype(_impl_.action_id_){0u}
    , decltype(_impl_.num_to_grant_){0u}
    , decltype(_impl_.score_mode_){0}
    , decltype(_impl_.audit_data_){uint64_t{0u}}
    , decltype(_impl_.audit_action_){0u}
  };
}

CMsgPendingEventAward::~CMsgPendingEventAward() {
  // @@protoc_insertion_point(destructor:CMsgPendingEventAward)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgPendingEventAward::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgPendingEventAward::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgPendingEventAward::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPendingEventAward)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.audit_action_) -
        reinterpret_cast<char*>(&_impl_.event_id_)) + sizeof(_impl_.audit_action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPendingEventAward::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 action_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_action_id(&has_bits);
          _impl_.action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_to_grant = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_to_grant(&has_bits);
          _impl_.num_to_grant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEventActionScoreMode_IsValid(val))) {
            _internal_set_score_mode(static_cast<::EEventActionScoreMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 audit_action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_audit_action(&has_bits);
          _impl_.audit_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 audit_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_audit_data(&has_bits);
          _impl_.audit_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgPendingEventAward::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPendingEventAward)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_id(), target);
  }

  // optional uint32 action_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_action_id(), target);
  }

  // optional uint32 num_to_grant = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_to_grant(), target);
  }

  // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_score_mode(), target);
  }

  // optional uint32 audit_action = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_audit_action(), target);
  }

  // optional uint64 audit_data = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_audit_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPendingEventAward)
  return target;
}

size_t CMsgPendingEventAward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPendingEventAward)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_id());
    }

    // optional uint32 action_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_action_id());
    }

    // optional uint32 num_to_grant = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_to_grant());
    }

    // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_score_mode());
    }

    // optional uint64 audit_data = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_audit_data());
    }

    // optional uint32 audit_action = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_audit_action());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgPendingEventAward::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgPendingEventAward::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgPendingEventAward::GetClassData() const { return &_class_data_; }


void CMsgPendingEventAward::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgPendingEventAward*>(&to_msg);
  auto& from = static_cast<const CMsgPendingEventAward&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgPendingEventAward)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_id_ = from._impl_.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.action_id_ = from._impl_.action_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_to_grant_ = from._impl_.num_to_grant_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.score_mode_ = from._impl_.score_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.audit_data_ = from._impl_.audit_data_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.audit_action_ = from._impl_.audit_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgPendingEventAward::CopyFrom(const CMsgPendingEventAward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPendingEventAward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPendingEventAward::IsInitialized() const {
  return true;
}

void CMsgPendingEventAward::InternalSwap(CMsgPendingEventAward* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPendingEventAward, _impl_.audit_action_)
      + sizeof(CMsgPendingEventAward::_impl_.audit_action_)
      - PROTOBUF_FIELD_OFFSET(CMsgPendingEventAward, _impl_.event_id_)>(
          reinterpret_cast<char*>(&_impl_.event_id_),
          reinterpret_cast<char*>(&other->_impl_.event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPendingEventAward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[6]);
}

// ===================================================================

class CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
}
CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry(const CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.key_, &from._impl_.key_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
}

inline void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){0u}
    , decltype(_impl_.value_){0}
  };
}

CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::~CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.key_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_key(), target);
  }

  // optional int32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  return target;
}

size_t CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());
    }

    // optional int32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::CopyFrom(const CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::InternalSwap(CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _impl_.value_)
      + sizeof(CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[7]);
}

// ===================================================================

class CMsgMonsterHunterMaterialQuantity::_Internal {
 public:
};

CMsgMonsterHunterMaterialQuantity::CMsgMonsterHunterMaterialQuantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterMaterialQuantity)
}
CMsgMonsterHunterMaterialQuantity::CMsgMonsterHunterMaterialQuantity(const CMsgMonsterHunterMaterialQuantity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterMaterialQuantity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.material_counts_){from._impl_.material_counts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterMaterialQuantity)
}

inline void CMsgMonsterHunterMaterialQuantity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.material_counts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgMonsterHunterMaterialQuantity::~CMsgMonsterHunterMaterialQuantity() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterMaterialQuantity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterMaterialQuantity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.material_counts_.~RepeatedPtrField();
}

void CMsgMonsterHunterMaterialQuantity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterMaterialQuantity::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterMaterialQuantity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.material_counts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterMaterialQuantity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry material_counts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_material_counts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterMaterialQuantity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterMaterialQuantity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry material_counts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_material_counts_size()); i < n; i++) {
    const auto& repfield = this->_internal_material_counts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterMaterialQuantity)
  return target;
}

size_t CMsgMonsterHunterMaterialQuantity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterMaterialQuantity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMonsterHunterMaterialQuantity.MaterialCountsEntry material_counts = 1;
  total_size += 1UL * this->_internal_material_counts_size();
  for (const auto& msg : this->_impl_.material_counts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterMaterialQuantity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterMaterialQuantity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterMaterialQuantity::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterMaterialQuantity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterMaterialQuantity*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterMaterialQuantity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterMaterialQuantity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.material_counts_.MergeFrom(from._impl_.material_counts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterMaterialQuantity::CopyFrom(const CMsgMonsterHunterMaterialQuantity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterMaterialQuantity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterMaterialQuantity::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterMaterialQuantity::InternalSwap(CMsgMonsterHunterMaterialQuantity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.material_counts_.InternalSwap(&other->_impl_.material_counts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterMaterialQuantity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[8]);
}

// ===================================================================

class CMsgMonsterHunterInvestigation::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterInvestigation>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_persona_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgMonsterHunterMaterialQuantity& match_rewards(const CMsgMonsterHunterInvestigation* msg);
  static void set_has_match_rewards(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgMonsterHunterMaterialQuantity& hunt_rewards(const CMsgMonsterHunterInvestigation* msg);
  static void set_has_hunt_rewards(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_success_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgMonsterHunterMaterialQuantity&
CMsgMonsterHunterInvestigation::_Internal::match_rewards(const CMsgMonsterHunterInvestigation* msg) {
  return *msg->_impl_.match_rewards_;
}
const ::CMsgMonsterHunterMaterialQuantity&
CMsgMonsterHunterInvestigation::_Internal::hunt_rewards(const CMsgMonsterHunterInvestigation* msg) {
  return *msg->_impl_.hunt_rewards_;
}
CMsgMonsterHunterInvestigation::CMsgMonsterHunterInvestigation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterInvestigation)
}
CMsgMonsterHunterInvestigation::CMsgMonsterHunterInvestigation(const CMsgMonsterHunterInvestigation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterInvestigation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_rewards_){nullptr}
    , decltype(_impl_.hunt_rewards_){nullptr}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.persona_id_){}
    , decltype(_impl_.success_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_match_rewards()) {
    _this->_impl_.match_rewards_ = new ::CMsgMonsterHunterMaterialQuantity(*from._impl_.match_rewards_);
  }
  if (from._internal_has_hunt_rewards()) {
    _this->_impl_.hunt_rewards_ = new ::CMsgMonsterHunterMaterialQuantity(*from._impl_.hunt_rewards_);
  }
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_state_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.success_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterInvestigation)
}

inline void CMsgMonsterHunterInvestigation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.match_rewards_){nullptr}
    , decltype(_impl_.hunt_rewards_){nullptr}
    , decltype(_impl_.hero_id_){0}
    , decltype(_impl_.persona_id_){0}
    , decltype(_impl_.success_state_){false}
  };
}

CMsgMonsterHunterInvestigation::~CMsgMonsterHunterInvestigation() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterInvestigation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterInvestigation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.match_rewards_;
  if (this != internal_default_instance()) delete _impl_.hunt_rewards_;
}

void CMsgMonsterHunterInvestigation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterInvestigation::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterInvestigation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.match_rewards_ != nullptr);
      _impl_.match_rewards_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.hunt_rewards_ != nullptr);
      _impl_.hunt_rewards_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.success_state_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.success_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterInvestigation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 persona_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_persona_id(&has_bits);
          _impl_.persona_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgMonsterHunterMaterialQuantity match_rewards = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_rewards(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hunt_rewards(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool success_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_success_state(&has_bits);
          _impl_.success_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterInvestigation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterInvestigation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 hero_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional int32 persona_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_persona_id(), target);
  }

  // optional .CMsgMonsterHunterMaterialQuantity match_rewards = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::match_rewards(this),
        _Internal::match_rewards(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hunt_rewards(this),
        _Internal::hunt_rewards(this).GetCachedSize(), target, stream);
  }

  // optional bool success_state = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_success_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterInvestigation)
  return target;
}

size_t CMsgMonsterHunterInvestigation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterInvestigation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgMonsterHunterMaterialQuantity match_rewards = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.match_rewards_);
    }

    // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hunt_rewards_);
    }

    // optional int32 hero_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_id());
    }

    // optional int32 persona_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_persona_id());
    }

    // optional bool success_state = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterInvestigation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterInvestigation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterInvestigation::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterInvestigation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterInvestigation*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterInvestigation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterInvestigation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_match_rewards()->::CMsgMonsterHunterMaterialQuantity::MergeFrom(
          from._internal_match_rewards());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_hunt_rewards()->::CMsgMonsterHunterMaterialQuantity::MergeFrom(
          from._internal_hunt_rewards());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.persona_id_ = from._impl_.persona_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.success_state_ = from._impl_.success_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterInvestigation::CopyFrom(const CMsgMonsterHunterInvestigation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterInvestigation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterInvestigation::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterInvestigation::InternalSwap(CMsgMonsterHunterInvestigation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterInvestigation, _impl_.success_state_)
      + sizeof(CMsgMonsterHunterInvestigation::_impl_.success_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterInvestigation, _impl_.match_rewards_)>(
          reinterpret_cast<char*>(&_impl_.match_rewards_),
          reinterpret_cast<char*>(&other->_impl_.match_rewards_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterInvestigation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[9]);
}

// ===================================================================

class CMsgMonsterHunterInvestigationGameState_HuntedBy::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterInvestigationGameState_HuntedBy>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_persona_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgMonsterHunterMaterialQuantity& hunt_rewards(const CMsgMonsterHunterInvestigationGameState_HuntedBy* msg);
  static void set_has_hunt_rewards(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_success_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgMonsterHunterMaterialQuantity&
CMsgMonsterHunterInvestigationGameState_HuntedBy::_Internal::hunt_rewards(const CMsgMonsterHunterInvestigationGameState_HuntedBy* msg) {
  return *msg->_impl_.hunt_rewards_;
}
CMsgMonsterHunterInvestigationGameState_HuntedBy::CMsgMonsterHunterInvestigationGameState_HuntedBy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterInvestigationGameState.HuntedBy)
}
CMsgMonsterHunterInvestigationGameState_HuntedBy::CMsgMonsterHunterInvestigationGameState_HuntedBy(const CMsgMonsterHunterInvestigationGameState_HuntedBy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterInvestigationGameState_HuntedBy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hunt_rewards_){nullptr}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.persona_id_){}
    , decltype(_impl_.success_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hunt_rewards()) {
    _this->_impl_.hunt_rewards_ = new ::CMsgMonsterHunterMaterialQuantity(*from._impl_.hunt_rewards_);
  }
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_state_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.success_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterInvestigationGameState.HuntedBy)
}

inline void CMsgMonsterHunterInvestigationGameState_HuntedBy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hunt_rewards_){nullptr}
    , decltype(_impl_.hero_id_){0}
    , decltype(_impl_.persona_id_){0}
    , decltype(_impl_.success_state_){false}
  };
}

CMsgMonsterHunterInvestigationGameState_HuntedBy::~CMsgMonsterHunterInvestigationGameState_HuntedBy() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterInvestigationGameState_HuntedBy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hunt_rewards_;
}

void CMsgMonsterHunterInvestigationGameState_HuntedBy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterInvestigationGameState_HuntedBy::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.hunt_rewards_ != nullptr);
    _impl_.hunt_rewards_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.success_state_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.success_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterInvestigationGameState_HuntedBy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 persona_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_persona_id(&has_bits);
          _impl_.persona_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hunt_rewards(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool success_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success_state(&has_bits);
          _impl_.success_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterInvestigationGameState_HuntedBy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 hero_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional int32 persona_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_persona_id(), target);
  }

  // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::hunt_rewards(this),
        _Internal::hunt_rewards(this).GetCachedSize(), target, stream);
  }

  // optional bool success_state = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_success_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  return target;
}

size_t CMsgMonsterHunterInvestigationGameState_HuntedBy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgMonsterHunterMaterialQuantity hunt_rewards = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hunt_rewards_);
    }

    // optional int32 hero_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_id());
    }

    // optional int32 persona_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_persona_id());
    }

    // optional bool success_state = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterInvestigationGameState_HuntedBy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterInvestigationGameState_HuntedBy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterInvestigationGameState_HuntedBy::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterInvestigationGameState_HuntedBy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterInvestigationGameState_HuntedBy*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterInvestigationGameState_HuntedBy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_hunt_rewards()->::CMsgMonsterHunterMaterialQuantity::MergeFrom(
          from._internal_hunt_rewards());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.persona_id_ = from._impl_.persona_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_state_ = from._impl_.success_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterInvestigationGameState_HuntedBy::CopyFrom(const CMsgMonsterHunterInvestigationGameState_HuntedBy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterInvestigationGameState.HuntedBy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterInvestigationGameState_HuntedBy::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterInvestigationGameState_HuntedBy::InternalSwap(CMsgMonsterHunterInvestigationGameState_HuntedBy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.success_state_)
      + sizeof(CMsgMonsterHunterInvestigationGameState_HuntedBy::_impl_.success_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterInvestigationGameState_HuntedBy, _impl_.hunt_rewards_)>(
          reinterpret_cast<char*>(&_impl_.hunt_rewards_),
          reinterpret_cast<char*>(&other->_impl_.hunt_rewards_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterInvestigationGameState_HuntedBy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[10]);
}

// ===================================================================

class CMsgMonsterHunterInvestigationGameState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterInvestigationGameState>()._impl_._has_bits_);
  static const ::CMsgMonsterHunterInvestigation& selected_investigation(const CMsgMonsterHunterInvestigationGameState* msg);
  static void set_has_selected_investigation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgMonsterHunterInvestigation&
CMsgMonsterHunterInvestigationGameState::_Internal::selected_investigation(const CMsgMonsterHunterInvestigationGameState* msg) {
  return *msg->_impl_.selected_investigation_;
}
CMsgMonsterHunterInvestigationGameState::CMsgMonsterHunterInvestigationGameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterInvestigationGameState)
}
CMsgMonsterHunterInvestigationGameState::CMsgMonsterHunterInvestigationGameState(const CMsgMonsterHunterInvestigationGameState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterInvestigationGameState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hunted_by_){from._impl_.hunted_by_}
    , decltype(_impl_.selected_investigation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selected_investigation()) {
    _this->_impl_.selected_investigation_ = new ::CMsgMonsterHunterInvestigation(*from._impl_.selected_investigation_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterInvestigationGameState)
}

inline void CMsgMonsterHunterInvestigationGameState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hunted_by_){arena}
    , decltype(_impl_.selected_investigation_){nullptr}
  };
}

CMsgMonsterHunterInvestigationGameState::~CMsgMonsterHunterInvestigationGameState() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterInvestigationGameState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterInvestigationGameState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hunted_by_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.selected_investigation_;
}

void CMsgMonsterHunterInvestigationGameState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterInvestigationGameState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterInvestigationGameState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hunted_by_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.selected_investigation_ != nullptr);
    _impl_.selected_investigation_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterInvestigationGameState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgMonsterHunterInvestigation selected_investigation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selected_investigation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgMonsterHunterInvestigationGameState.HuntedBy hunted_by = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hunted_by(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterInvestigationGameState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterInvestigationGameState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgMonsterHunterInvestigation selected_investigation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selected_investigation(this),
        _Internal::selected_investigation(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgMonsterHunterInvestigationGameState.HuntedBy hunted_by = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hunted_by_size()); i < n; i++) {
    const auto& repfield = this->_internal_hunted_by(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterInvestigationGameState)
  return target;
}

size_t CMsgMonsterHunterInvestigationGameState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterInvestigationGameState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMonsterHunterInvestigationGameState.HuntedBy hunted_by = 2;
  total_size += 1UL * this->_internal_hunted_by_size();
  for (const auto& msg : this->_impl_.hunted_by_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .CMsgMonsterHunterInvestigation selected_investigation = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selected_investigation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterInvestigationGameState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterInvestigationGameState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterInvestigationGameState::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterInvestigationGameState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterInvestigationGameState*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterInvestigationGameState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterInvestigationGameState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hunted_by_.MergeFrom(from._impl_.hunted_by_);
  if (from._internal_has_selected_investigation()) {
    _this->_internal_mutable_selected_investigation()->::CMsgMonsterHunterInvestigation::MergeFrom(
        from._internal_selected_investigation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterInvestigationGameState::CopyFrom(const CMsgMonsterHunterInvestigationGameState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterInvestigationGameState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterInvestigationGameState::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterInvestigationGameState::InternalSwap(CMsgMonsterHunterInvestigationGameState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hunted_by_.InternalSwap(&other->_impl_.hunted_by_);
  swap(_impl_.selected_investigation_, other->_impl_.selected_investigation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterInvestigationGameState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[11]);
}

// ===================================================================

class CMsgMonsterHunterCodexUpdateData_KillInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterCodexUpdateData_KillInfo>()._impl_._has_bits_);
  static void set_has_hero_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kill_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgMonsterHunterCodexUpdateData_KillInfo::CMsgMonsterHunterCodexUpdateData_KillInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterCodexUpdateData.KillInfo)
}
CMsgMonsterHunterCodexUpdateData_KillInfo::CMsgMonsterHunterCodexUpdateData_KillInfo(const CMsgMonsterHunterCodexUpdateData_KillInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterCodexUpdateData_KillInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){}
    , decltype(_impl_.kill_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hero_id_, &from._impl_.hero_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kill_count_) -
    reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.kill_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterCodexUpdateData.KillInfo)
}

inline void CMsgMonsterHunterCodexUpdateData_KillInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_id_){0}
    , decltype(_impl_.kill_count_){0}
  };
}

CMsgMonsterHunterCodexUpdateData_KillInfo::~CMsgMonsterHunterCodexUpdateData_KillInfo() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterCodexUpdateData.KillInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterCodexUpdateData_KillInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgMonsterHunterCodexUpdateData_KillInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterCodexUpdateData_KillInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterCodexUpdateData.KillInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.hero_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kill_count_) -
        reinterpret_cast<char*>(&_impl_.hero_id_)) + sizeof(_impl_.kill_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterCodexUpdateData_KillInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hero_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hero_id(&has_bits);
          _impl_.hero_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kill_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_kill_count(&has_bits);
          _impl_.kill_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterCodexUpdateData_KillInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterCodexUpdateData.KillInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 hero_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hero_id(), target);
  }

  // optional int32 kill_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_kill_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterCodexUpdateData.KillInfo)
  return target;
}

size_t CMsgMonsterHunterCodexUpdateData_KillInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterCodexUpdateData.KillInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 hero_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hero_id());
    }

    // optional int32 kill_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kill_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterCodexUpdateData_KillInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterCodexUpdateData_KillInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterCodexUpdateData_KillInfo::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterCodexUpdateData_KillInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterCodexUpdateData_KillInfo*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterCodexUpdateData_KillInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterCodexUpdateData.KillInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hero_id_ = from._impl_.hero_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kill_count_ = from._impl_.kill_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterCodexUpdateData_KillInfo::CopyFrom(const CMsgMonsterHunterCodexUpdateData_KillInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterCodexUpdateData.KillInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterCodexUpdateData_KillInfo::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterCodexUpdateData_KillInfo::InternalSwap(CMsgMonsterHunterCodexUpdateData_KillInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterCodexUpdateData_KillInfo, _impl_.kill_count_)
      + sizeof(CMsgMonsterHunterCodexUpdateData_KillInfo::_impl_.kill_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgMonsterHunterCodexUpdateData_KillInfo, _impl_.hero_id_)>(
          reinterpret_cast<char*>(&_impl_.hero_id_),
          reinterpret_cast<char*>(&other->_impl_.hero_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterCodexUpdateData_KillInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[12]);
}

// ===================================================================

class CMsgMonsterHunterCodexUpdateData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonsterHunterCodexUpdateData>()._impl_._has_bits_);
  static void set_has_player_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgMonsterHunterCodexUpdateData::CMsgMonsterHunterCodexUpdateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMonsterHunterCodexUpdateData)
}
CMsgMonsterHunterCodexUpdateData::CMsgMonsterHunterCodexUpdateData(const CMsgMonsterHunterCodexUpdateData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMonsterHunterCodexUpdateData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allies_){from._impl_.allies_}
    , decltype(_impl_.enemies_){from._impl_.enemies_}
    , decltype(_impl_.player_kills_){from._impl_.player_kills_}
    , decltype(_impl_.player_hero_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.player_hero_ = from._impl_.player_hero_;
  // @@protoc_insertion_point(copy_constructor:CMsgMonsterHunterCodexUpdateData)
}

inline void CMsgMonsterHunterCodexUpdateData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.allies_){arena}
    , decltype(_impl_.enemies_){arena}
    , decltype(_impl_.player_kills_){arena}
    , decltype(_impl_.player_hero_){0}
  };
}

CMsgMonsterHunterCodexUpdateData::~CMsgMonsterHunterCodexUpdateData() {
  // @@protoc_insertion_point(destructor:CMsgMonsterHunterCodexUpdateData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMonsterHunterCodexUpdateData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allies_.~RepeatedField();
  _impl_.enemies_.~RepeatedField();
  _impl_.player_kills_.~RepeatedPtrField();
}

void CMsgMonsterHunterCodexUpdateData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMonsterHunterCodexUpdateData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonsterHunterCodexUpdateData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allies_.Clear();
  _impl_.enemies_.Clear();
  _impl_.player_kills_.Clear();
  _impl_.player_hero_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonsterHunterCodexUpdateData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_hero = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_hero(&has_bits);
          _impl_.player_hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 allies = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_allies(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_allies(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 enemies = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_enemies(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enemies(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgMonsterHunterCodexUpdateData.KillInfo player_kills = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_kills(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonsterHunterCodexUpdateData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonsterHunterCodexUpdateData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_hero = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_hero(), target);
  }

  // repeated int32 allies = 2;
  for (int i = 0, n = this->_internal_allies_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_allies(i), target);
  }

  // repeated int32 enemies = 3;
  for (int i = 0, n = this->_internal_enemies_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_enemies(i), target);
  }

  // repeated .CMsgMonsterHunterCodexUpdateData.KillInfo player_kills = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_kills_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_kills(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonsterHunterCodexUpdateData)
  return target;
}

size_t CMsgMonsterHunterCodexUpdateData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonsterHunterCodexUpdateData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 allies = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.allies_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_allies_size());
    total_size += data_size;
  }

  // repeated int32 enemies = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.enemies_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_enemies_size());
    total_size += data_size;
  }

  // repeated .CMsgMonsterHunterCodexUpdateData.KillInfo player_kills = 4;
  total_size += 1UL * this->_internal_player_kills_size();
  for (const auto& msg : this->_impl_.player_kills_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 player_hero = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_hero());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonsterHunterCodexUpdateData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMonsterHunterCodexUpdateData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonsterHunterCodexUpdateData::GetClassData() const { return &_class_data_; }


void CMsgMonsterHunterCodexUpdateData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMonsterHunterCodexUpdateData*>(&to_msg);
  auto& from = static_cast<const CMsgMonsterHunterCodexUpdateData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonsterHunterCodexUpdateData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allies_.MergeFrom(from._impl_.allies_);
  _this->_impl_.enemies_.MergeFrom(from._impl_.enemies_);
  _this->_impl_.player_kills_.MergeFrom(from._impl_.player_kills_);
  if (from._internal_has_player_hero()) {
    _this->_internal_set_player_hero(from._internal_player_hero());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonsterHunterCodexUpdateData::CopyFrom(const CMsgMonsterHunterCodexUpdateData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonsterHunterCodexUpdateData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonsterHunterCodexUpdateData::IsInitialized() const {
  return true;
}

void CMsgMonsterHunterCodexUpdateData::InternalSwap(CMsgMonsterHunterCodexUpdateData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.allies_.InternalSwap(&other->_impl_.allies_);
  _impl_.enemies_.InternalSwap(&other->_impl_.enemies_);
  _impl_.player_kills_.InternalSwap(&other->_impl_.player_kills_);
  swap(_impl_.player_hero_, other->_impl_.player_hero_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonsterHunterCodexUpdateData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fshared_5fenums_2eproto_getter, &descriptor_table_dota_5fshared_5fenums_2eproto_once,
      file_level_metadata_dota_5fshared_5fenums_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CDOTAClientHardwareSpecs*
Arena::CreateMaybeMessage< ::CDOTAClientHardwareSpecs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientHardwareSpecs >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_Player*
Arena::CreateMaybeMessage< ::CDOTASaveGame_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_SaveInstance_PlayerPositions*
Arena::CreateMaybeMessage< ::CDOTASaveGame_SaveInstance_PlayerPositions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_SaveInstance_PlayerPositions >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_SaveInstance*
Arena::CreateMaybeMessage< ::CDOTASaveGame_SaveInstance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_SaveInstance >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame*
Arena::CreateMaybeMessage< ::CDOTASaveGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTACombatLogEntry*
Arena::CreateMaybeMessage< ::CMsgDOTACombatLogEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTACombatLogEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPendingEventAward*
Arena::CreateMaybeMessage< ::CMsgPendingEventAward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPendingEventAward >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterMaterialQuantity_MaterialCountsEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterMaterialQuantity*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterMaterialQuantity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterMaterialQuantity >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterInvestigation*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterInvestigation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterInvestigation >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterInvestigationGameState_HuntedBy*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterInvestigationGameState_HuntedBy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterInvestigationGameState_HuntedBy >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterInvestigationGameState*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterInvestigationGameState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterInvestigationGameState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterCodexUpdateData_KillInfo*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterCodexUpdateData_KillInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterCodexUpdateData_KillInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonsterHunterCodexUpdateData*
Arena::CreateMaybeMessage< ::CMsgMonsterHunterCodexUpdateData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonsterHunterCodexUpdateData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
